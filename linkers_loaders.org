#+TITLE: Note of Linkers and Loaders
#+OPTIONS: toc:2 num:3 H:4 ^:nil pri:t
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>

* 构建过程

构建分为四个步骤: 预处理, 编译, 汇编, 链接。

hello.c (+ hello.h) $\xrightarrow{\text{cpp}}$
hello.i $\xrightarrow{\text{gcc}}$
hello.s $\xrightarrow{\text{as}}$
hello.o (+ *.o, *.a, ...) $\xrightarrow{\text{ld}}$
a.out

预编译：
1. 删除所有的 =#define=, 展开所有的宏定义。
2. 处理所有的条件编译指令 =#if/#ifdef= 。
3. 处理 =#include= 递归将文件插入指令所在位置。

#+begin_src plain
$ gcc -E hello.c -o hello.i
# or
$ cpp hello.c > hello.i
#+end_src

编译：
#+begin_src plain
$ gcc -S hello.i -o hello.s
# 或同时做预编译和编译
$ cc1 hello.c
# 或
$ gcc -S hello.c -o hello.s
#+end_src

C++ 的对应 cc1 的程序为 cc1plus。

汇编：
#+begin_src plain
$ as hello.s -o hello.o
# 或
$ gcc -c hello.s -o hello.o
#+end_src

链接：
#+begin_src plain
$ ld Scrt1.o crti.o crtbeginS.o hello.o -lc crtendS.o crtn.o
#+end_src

完整过程：
#+begin_src plain
$ gcc test.c --verbose
# 分解简化为
$ cc1 test.c -o test.s
$ as test.s -o test.o
$ collect2 --dynamic-linker /lib64/ld-linux-x86-64.so.2 \
  PATHTO/Scrt1.o PATHTO/crti.o PATHTO/crtbeginS.o \
  test.o -lc \
  PATHTO/crtendS.o PATHTO/crtn.o
#+end_src


* 对象（object）文件

Linux 的可执行程序（动态库/静态库）为 ELF 格式（Executable linkable Format）。

#+begin_src plain
$ file /bin/ls
/bin/ls: ELF 64-bit LSB pie executable, x86-64, ...
#+end_src

对象文件以段（section）的形式存储。
代码编译出的机器码放在 =.text=, 全局变量和静态变量放在 =.data= 。
=.bss= 为未初始化的全局变量和静态变量预留大小信息。

可以用 objdump / readelf 来查看对象文件的内部结构。

#+begin_src plain
$ objdump -h test.o
0 .text            ...
1 .data            ...
2 .bss             ...
3 .rodata          ...
4 .comment         ...
5 .note.GNU-stack  ...
...
#+end_src

以 16 进制和反汇编打印所有段的内容：
#+begin_src plain
$ objdump -s -d test.o
...
#+end_src

ELF 文件格式：

| ELF header             |
| .text                  |
| .data                  |
| .bss                   |
| ...                    |
| section header table   |
| string tables(.strtab) |
| symbol tables(.symtab) |
| ...                    |

查看文件头：
#+begin_src plain
$ readelf -h test.o
ELF Header:
  ...
  Type: REL (Relocatable file)
  ...
#+end_src

查看段表（section header table）：
#+begin_src plain
$ readelf -S test.o
#+end_src

查看符号表（.symtab）：
#+begin_src plain
$ nm a.out
$ readelf -s a.out
#+end_src

C++ 解析修饰后的名称：
#+begin_src plain
> c++filt _ZN9addr2line9name_attrE
addr2line::name_attr
#+end_src

=extern "C"= 中 C++ 名称修饰机制不生效。

如何使库的头文件既支持 C 也支持 C++：
#+begin_src c++
#ifdef __cplusplus
extern "C" {
#endif
...
#ifdef __cplusplus
}
#endif
#+end_src

强符号与弱符号：
- 只允许一个强符号定义。
- 多个弱符号选占用空间最大的。

强引用与弱引用：
- 强引用必须找到定义。
- 弱引用未找到默认其为 0。

#+begin_src c
__attribute__ ((weakref)) void foo();
int main() { if (foo) foo(); }
#+end_src

DWARF: Debug With Arbitrary Record Format.

=strip= 去掉调试信息。


* 静态链接

最终合并所有 oeject 的段。

两步链接：
1. 空间与地址分配：获得所有 object 的各个段的信息，收集所有符号。
2. 符号解析与重定位：读入段数据、重定位信息，进行符号解析与重定位，调整代码中的地址。

#+begin_src plain
$ ld a.o b.o -e main -o a.out
#+end_src

链接前 =objdump -h= 所有 VMA（virtual memory address）都是 0，链接后都被分配了相应的虚拟内存地址。

.text 对应的重定位表为 .rela.text：
#+begin_src plain
$ objdump -r test.o
#+end_src

针对 C++ 使用 “Link Once” 段消除重复的模版实例化代码（或虚函数表、默认构造函数……）。

Linux 下程序的入口为 =_start=, 为 glibc 的一部分。
=_start= 完成一系列初始化工作之后调用 =main= ，然后做一些清理工作然后结束进程。

=.init= 和 =.fini= 段分别保存初始化代码和进程终止代码。
C++ 的全局构造和析构函数就放在里面。

静态库可以看做一组 object 文件的集合：
#+begin_src plain
$ ar -t /usr/ib/libc.a
init-first.o
libc-start.o
...
> objdump -t /usr/lib/libc.a | grep ' printf$'
0000000000000000 g     F .text  00000000000000c9 printf
#+end_src

* 装载

虚拟内存和页映射。

进程创建：
1. 创建虚拟地址空间（分配页目录）。
2. 建立虚拟地址空间和可执行文件的映射关系。
3. 将 PC 寄存器设置为可执行文件的入口地址，启动。

相同权限的多个 section 可以合并到一个 segment 来进行映射：
#+begin_src plain
$ readelf -l a.out
...
Section to Segment mapping:
...
#+end_src

可通过 =cat /proc/$pid/maps= 看进程的虚拟空间分布。

Linux 装载 ELF 过程：
1. bash 调 fork() 调 execute() 执行 ELF，最后返回 bash。
2. execute() 调 do_execute() 读文件头 128 字节，调用 search_binary_handler() ，调用 load_elf_binary()。


* 动态链接

#+begin_src plain
$ gcc lib.c -fPIC -shared -o lib.so
$ gcc test.c ./lib.so
$ ./a.out
#+end_src

只使用 =-shared= 为装载时重定位，但是无法在多个进程之间共享。

地址无关代码（PIC, Position-Independent Code）：把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，
这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。

全局偏移表（GOT）：在数据段里建立指向跨模块全局变量/函数的指针数组。

动态库被不同进程加载时，它的数据段部分在每个进程中都有独立的副本不会互相影响。

链接器在装载模块的时候会查找每个变量/函数所在的地址然后填充 GOT。

#+begin_src plain
$ objdump -h pic.so  # 查看 .got 段
$ objdump -R pic.so  # 查看重定位项
#+end_src

** PLT

延迟绑定（PLT，Procedure Linkage Table）：当函数第一次被用到时才进行绑定，加快启动速度。

每个外部函数在 PLT 中都有一个相应的项：
#+begin_src plain
bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jump _dl_runtime_resolve
#+end_src

一开始只把 =push n= 的地址填入 =bar@GOT=, 这样第一次就会把 =n= 压入堆栈，即为这个符号引用在重定位表 =.rel.plt= 中的下标。

然后再压入模块 id 调用 =resolve()=, 最终填入 =bar@GOT= 。

ELF 将 GOT 拆分为 =.got= 和 =.got.plt=, 前者保存全局变量引用的地址，后者保存函数引用的地址。

=.got.plt= 前三项分别为: =.dynamic= 段地址，本模块 ID, =resolve()= 的地址。

PLT 存在 =.plt= 包含上面的跳转代码。

** 相关 sections

动态链接时，操作系统在装载完可执行程序之后，先启动动态链接器 (=ld.so=)。
对可执行程序进行动态链接工作之后，转交控制权到可执行程序。

可执行文件的 =.interp= 段存了 =ld.so= 的地址。

=.dynamic= 段保存了动态链接器所需要的基本信息。各种表的地址。

#+begin_src plain
$ readelf -d lib.so
$ ldd lib.so
#+end_src

=.dynsym= 动态符号表（被 =.symtab= 包含）。

#+begin_src plain
$ readelf -sD lib.so
#+end_src

重定位表 =.rela.dyn= 和 =.rela.plt= 。分别修正 =.got= 和 =.got.plt= 。

#+begin_src plain
$ readelf -r lib.so
#+end_src

** 链接步骤

1. 动态链接器自举。
2. 将所有符号合并为全局符号表，再通过 =.dynamic= 递归寻找和装载 ELF 所依赖的共享对象。
  - **当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略。**
3. 重定位和初始化。
  - 遍历每个对象的重定位表，修正 GOT/PLT。
  - 执行共享对象的 =.init= 段。

显式运行时加载： =dlopen()=, =dlsym()=, =dlerror()=, =dlclose()= 。


* 共享库查找

如果 =.dynamic= 中 =DT_NEED= 项存的是绝对路径，则直接按照这个路径去查找。
否则在 =/lib=, =/usr/lib= 和 =/etc/ld.so.conf= 文件中指定的路径中查找。

更改 =/etc/ld.so.conf= 后需要执行 =ldconfig= 以更新 =/etc/ld.so.cache= 。

还可以通过 =LD_LIBRARY_PATH= 指定目录。也会影响 gcc 编译时查找库的路径。

=LD_PRELOAD= and =/etc/ld.so.preload= hack.

=LD_DEBUG==:
- files: 依赖哪个共享库，按什么步骤装载和初始化
- bindings: 显示符号绑定过程
- versions: 显示版本依赖关系
- all: all
- help: help
- ...

=-Wl= 传参数给链接器，比如 =-Wl,-rpath= 。
