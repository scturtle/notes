<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-06-14 Wed 17:59 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Note of "A Tour of C++"</title>
<meta name="author" content="scturtle" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="org.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Note of "A Tour of C++"</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgb61a0d9">1. The Basics</a></li>
<li><a href="#orgdf736dd">2. User-Defined Types</a></li>
<li><a href="#org6751b88">3. Modularity</a></li>
<li><a href="#orgb397c8d">4. Classes</a>
<ul>
<li><a href="#org3c9e62a">4.1. Dynamic Casting</a></li>
<li><a href="#orgf827a50">4.2. Copy and Move</a></li>
<li><a href="#orgcda26a1">4.3. Essential Operations</a></li>
</ul>
</li>
<li><a href="#org59276ab">5. Templates</a></li>
<li><a href="#orgf02dc4f">6. Library Overview</a></li>
<li><a href="#orgc8c873e">7. Strings and Regular Expressions</a>
<ul>
<li><a href="#org0649632">7.1. Regular Expressions</a></li>
</ul>
</li>
<li><a href="#org219a6d5">8. I/O Streams</a></li>
<li><a href="#orgee115ba">9. Containers</a></li>
<li><a href="#org7f6a9d2">10. Algorithms</a></li>
<li><a href="#org451364d">11. Utilities</a>
<ul>
<li><a href="#org5db590c">11.1. Smart Pointers</a></li>
<li><a href="#org1e09671">11.2. Specialized Containers</a></li>
</ul>
</li>
<li><a href="#org04a31e7">12. Numerics</a></li>
<li><a href="#org92a1b7a">13. Concurrency</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb61a0d9" class="outline-2">
<h2 id="orgb61a0d9"><span class="section-number-2">1.</span> The Basics</h2>
<div class="outline-text-2" id="text-1">
<p>
The minimal C++ program:
</p>
<div class="org-src-container">
<pre class="src src-C++">int main() { }
</pre>
</div>

<p>
If no value is returned, the system will receive a value
indicating successful completion.
</p>

<p>
A function declaration may contain argument names.
</p>
<div class="org-src-container">
<pre class="src src-C++">double square(double); // return the square of the argument
</pre>
</div>

<p>
If two functions are defined with the same name,
 but with different argument types,
 the compiler will choose the most appropriate function to invoke for each call.
</p>

<p>
Fundamental types: bool, char, int, double, unsigned.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-right">sizeof</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bool, char</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-right">8</td>
</tr>
</tbody>
</table>

<p>
<i>The usual arithmetic conversions: expressions
 are computed at the highest precision of its operands.</i>
</p>

<p>
Universal form based on curly-brace-delimited initializer lists:
</p>
<div class="org-src-container">
<pre class="src src-C++">  double d2 {2.3};
  complex&lt;double&gt; z3 = {1,2}; // the = is optional with { ... }
</pre>
</div>

<p>
<code>auto</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">auto b = true;
</pre>
</div>

<p>
<i>Range-for-statement</i>:
</p>
<div class="org-src-container">
<pre class="src src-c++">int v[] = {0,1,2,3,4,5,6,7,8,9};
for (auto&amp; x : v) cout &lt;&lt; x &lt;&lt; '\n';
</pre>
</div>

<p>
Use <code>nullptr</code> rather than <code>0</code> or <code>NULL</code>.
</p>

<p>
Prefer the <code>{}</code>-initializer syntax for declarations with a named type,
prefer the <code>=</code> syntax for the initialization in declarations using <code>auto</code>.
</p>
</div>
</div>

<div id="outline-container-orgdf736dd" class="outline-2">
<h2 id="orgdf736dd"><span class="section-number-2">2.</span> User-Defined Types</h2>
<div class="outline-text-2" id="text-2">
<p>
A <code>struct</code> is simply a class with members public by default:
</p>
<div class="org-src-container">
<pre class="src src-c++">struct V{ int val; };
</pre>
</div>

<p>
Class:
</p>
<div class="org-src-container">
<pre class="src src-c++">  class Vector {
  public:
    Vector(int s) : elem{new double[s]}, sz{s} {} // member initializer list
    double &amp;operator[](int i) { return elem[i]; } // operation
    int size() { return sz; }

  private:
    double* elem;
    int sz;
  };
</pre>
</div>

<p>
A <code>union</code> is a <code>struct</code> in which all members are allocated at the same address
so that the <code>union</code> occupies only as much space as its largest member.
Naturally, a <code>union</code> can hold a value for only one member at a time.
</p>
<div class="org-src-container">
<pre class="src src-c++">  union Value {
    char* s;
    int i;
  };
</pre>
</div>


<p>
Enumeration:
</p>
<div class="org-src-container">
<pre class="src src-c++">enum class Color { red, blue, green };
Color col = Color::red;
</pre>
</div>

<p>
An enumeration is a user-defined type so we can define operators for it.
You can remove the <code>class</code> from <code>enum</code> class to get a plain <code>enum</code>
(<code>int</code> value starts with 0).
</p>
</div>
</div>

<div id="outline-container-org6751b88" class="outline-2">
<h2 id="org6751b88"><span class="section-number-2">3.</span> Modularity</h2>
<div class="outline-text-2" id="text-3">
<p>
Declarations / interfaces, <code>Vector.h</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  class Vector {
  public:
    Vector(int s);
    double&amp; operator[](int i);
    int size();
  private:
    double* elem;
  };
</pre>
</div>

<p>
Avoid non-inline function definitions in headers.
</p>

<p>
Definitions / implementations, <code>Vector.cpp</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  #include "Vector.h"
  Vector::Vector(int s) :elem{new double[s]}, sz{s} { }
  double&amp; Vector::operator[](int i) { return elem[i]; }
  int Vector::size() { return sz; }
</pre>
</div>

<p>
Namespaces:
</p>
<div class="org-src-container">
<pre class="src src-c++">  namespace My_code {
    class complex {
      // ...
    };
    complex sqrt(complex);
    // ...
    int main();
  }
  int My_code::main(){
    // ...
  };
</pre>
</div>

<p>
Don't put a using-directive in a header file.
</p>

<p>
Exceptions:
</p>
<div class="org-src-container">
<pre class="src src-c++">  #include&lt;stdexcept&gt;
  throw out_of_range{"Vector::operator[]"};

  try { /* ... */ }
  catch (out_of_range) { /* ... */ }
  catch (...) { /* any exception */ }
</pre>
</div>

<p>
Logic errors: <code>logic_error</code>, <code>domain_error</code>, <code>invalid_argument</code>, <code>length_error</code>, <code>out_of_range</code>.
</p>

<p>
Runtime errors: <code>runtime_error</code>, <code>range_error</code>, <code>overflow_error</code>, <code>underflow_error</code>.
</p>

<p>
A function that should never throw an exception can be declared noexcept:
</p>
<div class="org-src-container">
<pre class="src src-c++">void user(int sz) noexcept;
</pre>
</div>

<p>
If still throws, the standard-library function <code>terminate()</code>
 is called to immediately terminate the program.
</p>

<p>
If operator <code>new</code> can't find memory to allocate, it throws a <code>std::bad_alloc</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  try { /* ... */ }
  catch (std::bad_alloc) {
    std::terminate(); // handle memory exhaustion
  }
</pre>
</div>

<p>
To rethrow the exception, we simply write <code>throw</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  catch (std::length_error) {
    cout &lt;&lt; "test failed: length error\n";
    throw; // rethrow
  }
</pre>
</div>

<p>
Compile time check:
</p>
<div class="org-src-container">
<pre class="src src-c++">  static_assert(4 &lt;= sizeof(int), "integers are too small");
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb397c8d" class="outline-2">
<h2 id="orgb397c8d"><span class="section-number-2">4.</span> Classes</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>const</code> function:
</p>
<div class="org-src-container">
<pre class="src src-c++">  double real() const { return re; }
</pre>
</div>

<p>
Operations change object itself should return reference:
</p>
<div class="org-src-container">
<pre class="src src-c++">  complex&amp; operator+=(complex z) { re+=z.re, im+=z.im; return *this; }
</pre>
</div>

<p>
Functions defined in a class are inlined by default.
It is possible to explicitly require inlining by
preceeding a function declaration with the keyword <code>inline</code>.
</p>

<p>
Clever ways of implementing operations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  complex operator−(complex a, complex b) { return a −= b; }
  // unary minus
  complex operator−(complex a) { return {−a.real(), −a.imag()}; }
</pre>
</div>

<p>
Destructor:
</p>
<div class="org-src-container">
<pre class="src src-c++">  ~Vector() { delete[] elem; }
</pre>
</div>

<p>
Initializer-list constructor:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector::Vector(std::initializer_list&lt;double&gt; lst)
      : elem{new double[lst.size()]}, sz{static_cast&lt;int&gt;(lst.size())} {
    copy(lst.begin(), lst.end(), elem);
  }
</pre>
</div>

<p>
<code>push_back</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector read(istream &amp;is) {
    Vector v;
    for (double d; is &gt;&gt; d;)
      v.push_back(d);
    return v;
  }
</pre>
</div>

<p>
Abstract type:
</p>
<div class="org-src-container">
<pre class="src src-c++">  class Container {
  public:
    // pure virtual function
    virtual double &amp;operator[](int) = 0;
    // const member function
    virtual int size() const = 0;
    // destructor
    virtual  ~Container() {}
  };
</pre>
</div>

<p>
The word <code>virtual</code> means "may be redefined later in a class derived from this one."
</p>

<p>
The curious <code>=0</code> syntax says the function is pure virtual;
that is, some class derived from <code>Container</code> <b>must</b> define the function.
</p>

<p>
A class with a pure virtual function is called an abstract class
and it's not possible to define an object of it.
</p>

<p>
As is common for abstract class, it does <b>not</b> have a constructor.
On the other hand, it <b>does</b> have a destructor and that destructor is <code>virtual</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  class Vector_container : public Container {
    Vector v;

  public:
    Vector_container(int s) : v(s) {}
    ~Vector_container() {}
    double &amp;operator[](int i) { return v[i]; }
    int size() const { return v.size(); }
  };
</pre>
</div>

<p>
Note that the member destructor (<code>~Vector()</code>) is implicitly invoked
by its class's destructor (<code>~Vector_container()</code>).
</p>

<p>
Virtual function table (<code>vtbl</code>).
</p>

<p>
A function in a derived class overrides a virtual function
in a base class if that function has exactly the same name and type.
</p>

<p>
A function with a slightly different name or a slightly different type
may be intended to override or it may be intended to be a separate function.
</p>

<p>
Explicitly state that a function is meant to override:
</p>
<div class="org-src-container">
<pre class="src src-c++">  void move(Point to) override;
</pre>
</div>
</div>

<div id="outline-container-org3c9e62a" class="outline-3">
<h3 id="org3c9e62a"><span class="section-number-3">4.1.</span> Dynamic Casting</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Dynamic casting:
</p>
<div class="org-src-container">
<pre class="src src-c++">  if (Smiley* p = dynamic_cast&lt;Smiley*&gt;(ps)) { /* ... */ }
</pre>
</div>
<p>
If the object pointed to by the argument of <code>dynamic_cast</code>
is not of the expected type or a class derived from the expected type,
<code>dynamic_cast</code> returns <code>nullptr</code>.
</p>

<p>
When a different type is unacceptable, we can simply <code>dynamic_cast</code> to a reference type.
If the object is not of the expected type, <code>bad_cast</code> is thrown:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Smiley &amp;r{dynamic_cast&lt;Smiley &amp;&gt;(*ps)};
</pre>
</div>

<p>
Better resource handling: return <code>unique_ptr</code> rather than
a naked pointer and store <code>unique_ptrs</code> in the container:
</p>
<div class="org-src-container">
<pre class="src src-c++">  vector&lt;unique_ptr&lt;Shape&gt;&gt; v;
  v.push_back(unique_ptr&lt;Shape&gt;{new Circle{p, r}});
</pre>
</div>

<p>
Now the object is owned by the <code>unique_ptr</code> which will delete the object
when it is no longer needed, that is, when its <code>unique_ptr</code> goes out of scope.
</p>
</div>
</div>

<div id="outline-container-orgf827a50" class="outline-3">
<h3 id="orgf827a50"><span class="section-number-3">4.2.</span> Copy and Move</h3>
<div class="outline-text-3" id="text-4-2">
<p>
By default, objects can be copied.
The default meaning of copy is memberwise copy: copy each member.
</p>

<div class="org-src-container">
<pre class="src src-c++">  complex z2{z1}; // copy initialization
  complex z3;
  z3 = z2;        // copy assignment
</pre>
</div>

<p>
Copy constructor and copy assignment:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector(const Vector &amp;a);            // copy constructor
  Vector &amp;operator=(const Vector &amp;a); // copy assignment

  Vector::Vector(const Vector &amp;a) : elem{new double[a.sz]}, sz{a.sz} {
    for (int i = 0; i != sz; ++i)
      elem[i] = a.elem[i];
  }

  Vector &amp;Vector::operator=(const Vector &amp;a) {
    double* p = new double[a.sz];
    for (int i = 0; i != a.sz; ++i)
      p[i] = a.elem[i];
    delete[] elem; // delete old elements
    elem = p;
    sz = a.sz;
    return *this;
  }
</pre>
</div>

<p>
To avoid copying in returning value:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector foo(/* ... */) {
    Vector res;
    // ...
    return res;
  }

</pre>
</div>

<p>
Move constructor and move assignment should be implemented:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector(Vector &amp;&amp;a);            // move constructor
  Vector &amp;operator=(Vector &amp;&amp;a); // move assignment

  Vector::Vector(Vector &amp;&amp;a)
      : elem{a.elem}, sz{a.sz} { // "grab the elements" from a
    a.elem = nullptr; a.sz = 0;  // now a has no elements
  }
</pre>
</div>

<p>
The <code>&amp;&amp;</code> means <i>rvalue</i> reference and is a reference to which we can bind an rvalue.
The word "rvalue" is intended to complement "lvalue," which roughly means
"something that can appear on the left-hand side of an assignment."
So an <b>rvalue</b> is – to a first approximation – <b>a value that you can't assign to</b>,
such as an integer returned by a function call.
Thus, an rvalue reference is a reference to something that nobody else can assign to,
so that we can safely "steal" its value.
</p>

<p>
A move operation is applied when an rvalue reference is used
as an initializer or as the right-hand side of an assignment.
</p>

<p>
Manually move with <code>std::move</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector f() {
    // ...
    z = x;            // we get a copy
    y = std::move(x); // we get a move
    return z;         // we get a move
  }
</pre>
</div>
</div>
</div>


<div id="outline-container-orgcda26a1" class="outline-3">
<h3 id="orgcda26a1"><span class="section-number-3">4.3.</span> Essential Operations</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-c++">  class X {
  public:
    X(Sometype);             // ordinary constructor: create an object
    X();                     // default constructor
    X(const X &amp;);            // copy constructor
    X(X &amp;&amp;);                 // move constructor
    X &amp;operator=(const X &amp;); // copy assignment: clean up target and copy
    X &amp;operator=(X &amp;&amp;);      // move assignment: clean up target and move
    ~X();                    // destructor: clean up
    // ...
  };
</pre>
</div>

<p>
Except for the ordinary constructor, these can be generated by compiler:
</p>
<div class="org-src-container">
<pre class="src src-c++">  class Y {
  public:
    Y(Sometype);
    Y(const Y &amp;) = default; // I really want the default copy constructor
    Y(Y &amp;&amp;) = default;      // I really want the default copy constructor
    // ...
  };
</pre>
</div>

<p>
If you are explicit about some defaults,
other default definitions will not be generated.
</p>

<p>
Eliminate the default definitions of those two operations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  class Shape {
  public:
    // no copy operations
    Shape(const Shape &amp;) = delete;
    Shape &amp;operator=(const Shape &amp;) = delete;
    // no move operations
    Shape(Shape &amp;&amp;) = delete;
    Shape &amp;operator=(Shape &amp;&amp;) = delete;
    ~Shape();
    // ...
  };
</pre>
</div>

<p>
A constructor taking a single argument defines a conversion from its argument type,
but if only <code>explicit</code> conversion is allowed:
</p>
<div class="org-src-container">
<pre class="src src-c++">  class Vector {
  public:
    explicit Vector(int s); // no implicit conversion from int to Vector
    // ...
  };
</pre>
</div>

<p>
<i>C++ also offers a garbage collection interface
 so that you can plug in a garbage collector.</i>
</p>

<p>
In the C++ standard library, RAII (Resource Acquisition Is Initialization) is pervasive:
 for example, memory (string, vector, map, <code>unordered_map</code>, etc.),
 files (ifstream, ofstream, etc.), threads (thread), locks (<code>lock_guard</code>, <code>unique_lock</code>, etc.),
 and general objects (through <code>unique_ptr</code> and <code>shared_ptr</code>).
</p>
</div>
</div>
</div>

<div id="outline-container-org59276ab" class="outline-2">
<h2 id="org59276ab"><span class="section-number-2">5.</span> Templates</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-c++">  template&lt;typename T&gt;
  class Vector {
  private:
    T* elem;
    // ...
  }
  Vector&lt;T&gt;::Vector(int s) { // ...
</pre>
</div>

<p>
Using <code>class</code> to introduce a type parameter is equivalent to using <code>typename</code>,
and in older code we often see <code>template&lt;class T&gt;</code> as the prefix.
</p>

<p>
The <code>&gt;&gt;</code> in <code>Vector&lt;list&lt;int&gt;&gt;</code> terminates the nested template arguments;
it is not a misplaced input operator.
It is not (as in C++98) necessary to place a space between the two &gt;s.
</p>

<p>
Provide <code>begin()</code> and <code>end()</code> to support <code>range-for</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  template &lt;typename T&gt;
  T *begin(Vector&lt;T&gt; &amp;x) {
    // pointer to first element or nullptr
    return x.size() ? &amp;x[0] : nullptr;
  }
  template &lt;typename T&gt;
  T *end(Vector&lt;T&gt; &amp;x) {
    // pointer to one-past-last element
    return begin(x) + x.size();
  }
  void f2(Vector&lt;string&gt; &amp;vs) {
    for (auto &amp;s : vs)
      cout &lt;&lt; s &lt;&lt; '\n';
  }
</pre>
</div>

<p>
Templates are a compile-time mechanism,
so their use incurs no run-time overhead compared to hand-crafted code.
</p>

<p>
A template can take value arguments:
</p>
<div class="org-src-container">
<pre class="src src-c++">  template&lt;typename T, int N&gt;
  struct Buffer {
    using value_type = T;
    constexpr int size() { return N; }
    T[N];
    // ...
  };
</pre>
</div>

<p>
The alias <code>value_type</code> and the <code>constexpr</code> function are provided
to allow users (read-only) access to the template arguments.
</p>

<p>
Can be used to create arbitrarily sized buffers on stack:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Buffer&lt;char,1024&gt; glob;
</pre>
</div>

<p>
Function object: objects that can be called like functions:
</p>
<div class="org-src-container">
<pre class="src src-c++">  template&lt;typename T&gt;
  class Less_than {
    const T val; // value to compare against
  public:
    Less_than(const T &amp;v) : val(v) {}
    bool operator()(const T &amp;x) const { return x &lt; val; } // call operator
  };

  count(vec, Less_than&lt;int&gt;{x});
</pre>
</div>

<p>
Lambda expression:
</p>
<div class="org-src-container">
<pre class="src src-c++">  count(vec, [&amp;](int a) { return a &lt; x; });
</pre>
</div>

<p>
Capture nothing is <code>[ ]</code> , capture all local names used by reference is <code>[&amp;]</code> ,
 and capture all local names used by value is <code>[=]</code> .
</p>

<p>
Had we wanted to capture only x, we could have said so: <code>[&amp;x]</code> .
Had we wanted to give the generated object a copy of x,
we could have said so: <code>[=x]</code> .
</p>

<p>
Variadic templates:
</p>
<div class="org-src-container">
<pre class="src src-c++">  void f() { } // do nothing
  template&lt;typename T, typename... Tail&gt;
  void f(T head, Tail... tail) {
    g(head);    // do something to head
    f(tail...); // try again with tail
  }
</pre>
</div>

<p>
Another example in chapter 11:
</p>
<div class="org-src-container">
<pre class="src src-c++">  template &lt;typename T, typename... Args&gt;
  unique_ptr&lt;T&gt; make_unique(Args &amp;&amp;... args) {
    return std::unique_ptr&lt;T&gt;{new T{std::forward&lt;Args&gt;(args)...}};
  }
</pre>
</div>

<p>
Aliases:
</p>
<div class="org-src-container">
<pre class="src src-c++">  // in &lt;cstddef&gt;
  using size_t = unsigned int;
</pre>
</div>

<p>
It is very common for a parameterized type to provide
an alias for types related to their template arguments.
</p>
<div class="org-src-container">
<pre class="src src-c++">  template&lt;typename T&gt;
  class Vector {
  public:
    using value_type = T;
    // ...
  };
</pre>
</div>

<p>
In fact, every standard-library container provides
<code>value_type</code> as the name of its value type.
</p>
<div class="org-src-container">
<pre class="src src-c++">  template &lt;typename C&gt;
  using Element_type = typename C::value_type;

  template &lt;typename Container&gt;
  void algo(Container &amp;c) {
    Vector&lt;Element_type&lt;Container&gt;&gt; vec;
    // ...
  }
</pre>
</div>

<p>
A function template argument needs to be explicitly mentioned
only if it cannot be deduced or if there is no default:
</p>
<div class="org-src-container">
<pre class="src src-c++">  template &lt;typename Target = string, typename Source = string&gt;
  Target to(Source arg) {
    // ...
  }
  int main() {
    auto x1 = to&lt;string, double&gt;(1.2);
    auto x2 = to&lt;string&gt;(1.2); // Source is deduced to double
    auto x3 = to&lt;&gt;(1.2);
    auto x4 = to(1.2);
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf02dc4f" class="outline-2">
<h2 id="orgf02dc4f"><span class="section-number-2">6.</span> Library Overview</h2>
<div class="outline-text-2" id="text-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Selected Standard Library Headers</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">header</th>
<th scope="col" class="org-left">declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&lt;string&gt;</td>
<td class="org-left">string, basic_string</td>
</tr>

<tr>
<td class="org-left">&lt;regex&gt;</td>
<td class="org-left">regex, smatch</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;fstream&gt;</td>
<td class="org-left">fstream, ifstream, ofstream</td>
</tr>

<tr>
<td class="org-left">&lt;iostream&gt;</td>
<td class="org-left">istream, ostream, cin, cout</td>
</tr>

<tr>
<td class="org-left">&lt;sstream&gt;</td>
<td class="org-left">istrstream, ostrstream</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;array&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">&lt;vector&gt;</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">&lt;set&gt;</td>
<td class="org-left">set, multiset</td>
</tr>

<tr>
<td class="org-left">&lt;map&gt;</td>
<td class="org-left">map, multimap</td>
</tr>

<tr>
<td class="org-left">&lt;unordered_map&gt;</td>
<td class="org-left">unordered_map, unordered_multimap</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;algorithm&gt;</td>
<td class="org-left">copy(), find(), sort()</td>
</tr>

<tr>
<td class="org-left">&lt;random&gt;</td>
<td class="org-left">default_random_engine, normal_distribution</td>
</tr>

<tr>
<td class="org-left">&lt;memory&gt;</td>
<td class="org-left">unique_ptr, shared_ptr, allocator</td>
</tr>

<tr>
<td class="org-left">&lt;utility&gt;</td>
<td class="org-left">move(), swap(), pair</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;cmath&gt;</td>
<td class="org-left">sqrt(), pow()</td>
</tr>

<tr>
<td class="org-left">&lt;complex&gt;</td>
<td class="org-left">complex, sqrt(), pow()</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;future&gt;</td>
<td class="org-left">future, promise</td>
</tr>

<tr>
<td class="org-left">&lt;thread&gt;</td>
<td class="org-left">thread</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;forward_list&gt;</td>
<td class="org-left">forward_list</td>
</tr>

<tr>
<td class="org-left">&lt;stdexcept&gt;</td>
<td class="org-left">length_error, out_of_range, runtime_error</td>
</tr>

<tr>
<td class="org-left">&lt;chrono&gt;</td>
<td class="org-left">duration, time_point</td>
</tr>

<tr>
<td class="org-left">&lt;ios&gt;</td>
<td class="org-left">hex,dec,scientific,fixed,defaultfloat</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgc8c873e" class="outline-2">
<h2 id="orgc8c873e"><span class="section-number-2">7.</span> Strings and Regular Expressions</h2>
<div class="outline-text-2" id="text-7">
<p>
A string is mutable: <code>=</code>, <code>+=</code>, <code>[]</code>.
</p>

<p>
<code>.size()</code>, <code>.insert()</code>, <code>.erase()</code>, <code>.find()</code> (<code>string::npos</code>),
<code>.substr()</code>, <code>.replace()</code>, <code>.c_str()</code> (read-only).
</p>

<p>
<b>short-string optimization</b>: short string values are kept in the string object itself
and only longer strings are placed on free store.
</p>

<p>
<code>string</code> is really an alias for a general template <code>basic_string</code>
with the character type <code>char</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">using string = basic_string&lt;char&gt;
</pre>
</div>

<p>
<code>wstring</code>, <code>u16string</code>, <code>u32string</code>.
</p>
</div>

<div id="outline-container-org0649632" class="outline-3">
<h3 id="org0649632"><span class="section-number-3">7.1.</span> Regular Expressions</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Pattern:
</p>
<div class="org-src-container">
<pre class="src src-c++">regex pat (R"(\w{2}\s∗\d{5}(−\d{4})?)");
</pre>
</div>

<p>
<code>regex_match()</code>, <code>regex_search()</code>, <code>regex_replace()</code>, <code>regex_iterator</code>, <code>regex_token_iterator</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  int lineno = 0;
  for (string line; getline(cin, line);) {
    ++lineno;
    smatch matches;
    if (regex_search(line, matches, pat))
      cout &lt;&lt; lineno &lt;&lt; ": " &lt;&lt; matches[0] &lt;&lt; '\n';
  }
</pre>
</div>

<p>
An smatch is a vector of sub-matches of type string.
The first element, here <code>matches[0]</code>, is the complete match.
</p>

<p>
Sub-match:
</p>
<div class="org-src-container">
<pre class="src src-c++">  if (1 &lt; matches.size() &amp;&amp; matches[1].matched)
    cout &lt;&lt; "\t: " &lt;&lt; matches[1] &lt;&lt; '\n';
</pre>
</div>

<p>
Regular expressions are compiled into state machines for efficient execution.
</p>

<p>
Character classes and abbreviations (skipped here).
</p>

<p>
Iterator:
</p>
<div class="org-src-container">
<pre class="src src-c++">  string input = "aa as; asd ++eˆasdf asdfg";
  regex pat{R"(\s+(\w+))"};
  for (sregex_iterator p(input.begin(), input.end(), pat);
       p != sregex_iterator{}; ++p)
    cout &lt;&lt; (*p)[1] &lt;&lt; '\n';
</pre>
</div>

<p>
Return strings by value (rely on move semantics).
</p>

<p>
Use a string_stream or a generic value extraction function (such as <code>to&lt;X&gt;</code>)
for numeric conversion of strings.
</p>
</div>
</div>
</div>

<div id="outline-container-org219a6d5" class="outline-2">
<h2 id="org219a6d5"><span class="section-number-2">8.</span> I/O Streams</h2>
<div class="outline-text-2" id="text-8">
<p>
By default, <code>&gt;&gt;</code> skips initial whitespace.
</p>

<p>
By default, a whitespace character, such as a space or a newline, terminates the read.
You can read a whole line (including the terminating newline character) using the <code>getline()</code> function.
</p>
<div class="org-src-container">
<pre class="src src-c++">getline(cin,str);
</pre>
</div>

<p>
I/O state:
</p>
<div class="org-src-container">
<pre class="src src-c++">  while (cin &gt;&gt; i)
    res.push_back(i);

  if (cin.eof()) {
    // ...
  } else if (cin.fail()) { // a potentially recoverable error
    cin.clear();           // reset the state to good()
    // ...
    // if fail again
    cin.setstate(ios_base::failbit); // add fail() to cin's state
  }
</pre>
</div>

<p>
Custom <code>&lt;&lt;</code> and <code>&gt;&gt;</code> :
</p>
<div class="org-src-container">
<pre class="src src-c++">  ostream &amp;operator&lt;&lt;(ostream &amp;os, const Entry &amp;e) {
    return os &lt;&lt; "{\"" &lt;&lt; e.name &lt;&lt; "\", " &lt;&lt; e.number &lt;&lt; "}";
  }

  istream &amp;operator&gt;&gt;(istream &amp;is, Entry &amp;e) {
    char c, c2;
    if (is &gt;&gt; c &amp;&amp; c == '{' &amp;&amp; is &gt;&gt; c2 &amp;&amp; c2 == '"') { // start with a {"
      string name;                                      // read a string name
      while (is.get(c) &amp;&amp; c != '"')                     // end with "
        name += c;
      if (is &gt;&gt; c &amp;&amp; c == ',') { // seperated by ,
        int number = 0;
        if (is &gt;&gt; number &gt;&gt; c &amp;&amp; c == '}') { // read the number and a }
          e = {name, number};
          return is;
        }
      }
    }
    // oh no
    is.setstate(ios_base::failbit);
    return is;
  }
</pre>
</div>

<p>
Formatting:
</p>
<div class="org-src-container">
<pre class="src src-c++">  #include&lt;iostream&gt;
  #include&lt;ios&gt;
  using namespace std;

  int main(){
    cout &lt;&lt; 1234 &lt;&lt; ','
         &lt;&lt; hex &lt;&lt; 1234 &lt;&lt; ','
         &lt;&lt; oct &lt;&lt; 1234 &lt;&lt; '\n';
    // 1234,4d2,2322
    constexpr double d = 123.456;
    cout &lt;&lt; d &lt;&lt; "; "
         &lt;&lt; scientific &lt;&lt; d &lt;&lt; "; "
         &lt;&lt; fixed &lt;&lt; d &lt;&lt; "; "
         &lt;&lt; defaultfloat &lt;&lt; d &lt;&lt; '\n';
    // 123.456; 1.234560e+02; 123.456000; 123.456
    cout.precision(2);
    cout &lt;&lt; fixed &lt;&lt; d &lt;&lt; '\n';
    // 123.46
  }
</pre>
</div>

<p>
<code>precision()</code> affects <code>defaultfloat</code>, <code>scientific</code>, <code>fixed</code>.
</p>

<p>
<code>#include &lt;iomanip&gt;</code> when using standard manipulators taking arguments.
</p>

<p>
Test files for reading and writing:
</p>
<div class="org-src-container">
<pre class="src src-c++">  ofstream ofs("target");
  if (!ofs) error("couldn't open 'target' for writing");
  ifstream ifs("source");
  if (!ifs) error("couldn't open 'source' for reading");
</pre>
</div>

<p>
<code>&lt;sstream&gt;</code> : <code>istringstream</code>,  <code>ostringstream</code>, <code>stringstream</code>.
</p>

<p>
The result from an istringstream can be read using <code>str()</code>.
</p>

<p>
Use <code>stringstream</code> for in-memory formatting.
</p>
</div>
</div>

<div id="outline-container-orgee115ba" class="outline-2">
<h2 id="orgee115ba"><span class="section-number-2">9.</span> Containers</h2>
<div class="outline-text-2" id="text-9">
<p>
typical implementation of vector:
</p>
<ul class="org-ul">
<li>elem : a handle holding pointers to the first element</li>
<li>space : one-past-the-last element</li>
<li>last : one-past-the-last allocated space</li>
<li>alloc : allocator from which can acquire memory for elements</li>
</ul>

<p>
Initilize:
</p>
<div class="org-src-container">
<pre class="src src-c++">  vector&lt;int&gt; v1 = {1, 2, 3, 4}; // size is 4
  vector&lt;string&gt; v2;             // size is 0
  vector&lt;Shape*&gt; v3(23);         // size is 23; initial element value: nullptr
  vector&lt;double&gt; v4(32, 9.9);    // size is 32; initial element value: 9.9
</pre>
</div>

<p>
A vector can be copied in assignments and initializations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  vector&lt;Entry&gt; book2 = phone_book;
</pre>
</div>

<p>
When you insert a new element, its value is copied into the container.
</p>

<p>
The <code>at()</code> operation throws an exception of type <code>out_of_range</code>
if its argument is out of the vector's range.
</p>

<p>
<code>list</code> : doubly-linked list.
</p>

<p>
<code>map</code> : a search tree (a red-black tree).
</p>

<p>
If a key isn’t found with <code>[]</code>, it is inserted into the <code>map</code> with a default value for its value.
</p>

<p>
<code>nordered_map</code>.
The standard-library provides a default hash function for strings
as well as for other built-in and standard-library types.
If necessary, you can provide your own.
</p>

<p>
A hash function is often provided as a function object:
</p>
<div class="org-src-container">
<pre class="src src-c++">  struct Record {
    string name;
    int product_code;
    // ...
  };
  // a hash function for Record
  struct Rhash {
    size_t operator()(const Record &amp;r) const {
      return hash&lt;string&gt;()(r.name) ^ hash&lt;int&gt;()(r.product_code);
    }
  };
  // set of Recoreds using Rhash for lookup
  unordered_set&lt;Record, Rhash&gt; my_set;
</pre>
</div>

<p>
Creaing a new hash function by combining existing hash functions
using exclusive or (^) is simple and often very effective.
</p>

<ul class="org-ul">
<li>vector&lt;T&gt;, list&lt;T&gt;, forward_list&lt;T&gt;</li>
<li>map&lt;K,V&gt;, multimap&lt;K,V&gt;, unordered_map&lt;K,V&gt;, unordered_multimap&lt;K,V&gt;</li>
<li>set&lt;T&gt;, multiset&lt;T&gt;, unordered_set&lt;T&gt; unordered_multiset&lt;T&gt;</li>
<li>deque&lt;T&gt;, queue&lt;T&gt;, stack&lt;T&gt;, priority_queue&lt;T&gt;</li>
<li>fixed-size array <code>array&lt;T,N&gt;</code>, bitset&lt;N&gt;</li>
</ul>

<p>
Please note that a vector is usually more efficient than a list
for short sequences of small elements (even for insert() and erase()).
</p>

<p>
Use <code>forward_list</code> for sequences that are usually empty.
</p>

<p>
When it comes to performance, don’t trust your intuition: measure.
</p>

<p>
Pass a container by reference and return a container by value.
</p>
</div>
</div>

<div id="outline-container-org7f6a9d2" class="outline-2">
<h2 id="org7f6a9d2"><span class="section-number-2">10.</span> Algorithms</h2>
<div class="outline-text-2" id="text-10">
<div class="org-src-container">
<pre class="src src-c++">  sort(vec.begin(), vec.end());
  unique_copy(vec.begin(), vec.end(), lst.begin());
  unique_copy(vec.begin(), vec.end(), back_inserter(lst));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++">   if (find(s.begin(), s.end(), c) != s.end())
     /* ... */;
</pre>
</div>

<p>
each container knows its iterator types and makes them available
under the conventional names <code>iterator</code> and <code>const_iterator</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  template &lt;typename C, typename V&gt;
  vector&lt;typename C::iterator&gt; find_all(C &amp;c, V v) {
</pre>
</div>

<p>
The typename is needed to inform the compiler that
C's iterator is supposed to be a type and not a value of some type.
</p>

<p>
With aliases:
</p>
<div class="org-src-container">
<pre class="src src-c++">template&lt;typename T&gt;
using Iterator = typename T::iterator;

template&lt;typename C, typename V&gt;
vector&lt;Iterator&lt;C&gt;&gt; find_all(C&amp; c, V v) {
</pre>
</div>

<p>
Stream iterator:
</p>
<div class="org-src-container">
<pre class="src src-c++">  int main() {
    ostream_iterator&lt;string&gt; oo{cout}; // write strings to cout
    *oo = "Hello, ";  // meaning cout&lt;&lt;"Hello, "
    ++oo;
    *oo = "world!\n"; // meaning cout&lt;&lt;"world!\n"
    istream_iterator&lt;string&gt; ii{cin};
    istream_iterator&lt;string&gt; eos{}; // indicate the end of input
  }
</pre>
</div>

<p>
Manipulate files:
</p>
<div class="org-src-container">
<pre class="src src-c++">  int unique_copy(string from, string to) {
    ifstream is{from};
    ofstream os{to};
    set&lt;string&gt; b{istream_iterator&lt;string&gt;{is}, istream_iterator&lt;string&gt;{}};
    copy(b.begin(), b.end(), ostream_iterator&lt;string&gt;{os, "\n"});
    return !is.eof() || !os;
  }
</pre>
</div>

<p>
Predictors:
</p>
<div class="org-src-container">
<pre class="src src-c++">  struct Greater_than {
    int val;
    Greater_than(int v) : val{v} {}
    bool operator()(const pair&lt;string, int&gt; &amp;r) { return r.second &gt; val; }
  };
  // use as
  auto p = find_if(m.begin(), m.end(), Greater_than{42});
  // or lambda
  auto p = find_if(m.begin(), m.end(), [](const pair&lt;string,int&gt;&amp; r) { return r.second&gt;42; });
</pre>
</div>

<p>
A predicate must not modify its argument.
</p>

<p>
Functions in <code>&lt;algorithm&gt;</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  p = find(b, e, x);
  p = find_if(b, e, f);
  n = count(b, e, x);
  n = count_if(b, e, f);
  replace(b, e, v, v2);
  replace_if(b, e, f, v2);
  p = copy(b, e, out); // from [b:e) to [out:p)
  p = copy_if(b, e, out, f);
  p = move(b, e, out);
  p = unique_copy(b, e, out);
  sort(b, e);
  sort(b, e, f);                   // Sort elements of [b:e) using f
  (p1, p2) = equal_range(b, e, v); // [p1:p2) is the subsequence with the value v
  p = merge(b, e, b2, e2, out);
</pre>
</div>

<p>
Some algorithms, such as <code>replace()</code> and <code>sort()</code>, modify element values,
But <b>no algorithm add or subtract elements</b> of a container.
</p>

<p>
If you want to add elements, you need something,
such as an <code>back_inserter</code> that knows about the container.
</p>
</div>
</div>

<div id="outline-container-org451364d" class="outline-2">
<h2 id="org451364d"><span class="section-number-2">11.</span> Utilities</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org5db590c" class="outline-3">
<h3 id="org5db590c"><span class="section-number-3">11.1.</span> Smart Pointers</h3>
<div class="outline-text-3" id="text-11-1">
<p>
In <code>&lt;memory&gt;</code>, the stan- dard library provides two 
smart pointers to help manage objects on the free store:
</p>
<ol class="org-ol">
<li><code>unique_ptr</code> to represent unique ownership</li>
<li><code>shared_ptr</code> to represent shared ownership</li>
</ol>

<p>
The <code>shared_ptr</code> is similar to <code>unique_ptr</code> except that
shared_ptrs are <b>copied rather than moved</b>.
</p>

<p>
The shared_ptrs for an object share ownership of an object and
that object is destroyed when the last of its shared_ptrs is destroyed.
</p>

<p>
the standard library (in <code>&lt;memory&gt;</code>) provides a function <code>make_shared()</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  shared_ptr&lt;S&gt; p1{new S{1, "Ankh Morpork", 4.65}};
  auto p2 = make_shared&lt;S&gt;(2, "Oz", 7.62);
</pre>
</div>

<p>
Use <code>unique_ptr</code> to refer to objects of polymorphic type.
Use <code>shared_ptr</code> to refer to shared objects.
</p>
</div>
</div>

<div id="outline-container-org1e09671" class="outline-3">
<h3 id="org1e09671"><span class="section-number-3">11.2.</span> Specialized Containers</h3>
<div class="outline-text-3" id="text-11-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Almost Conainers</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Container</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T[N]</td>
<td class="org-left">Built-in array</td>
</tr>

<tr>
<td class="org-left">array&lt;T,N&gt;</td>
<td class="org-left">Like the built-in array, but <b>with most problems solved</b></td>
</tr>

<tr>
<td class="org-left">bitset&lt;N&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">vector&lt;bool&gt;</td>
<td class="org-left">A sequence of bits <b>compactly</b> stored in a specialization of vector</td>
</tr>

<tr>
<td class="org-left">pair&lt;T,U&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">tuple&lt;T&#x2026;&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">basic_string&lt;C&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">valarray&lt;T&gt;</td>
<td class="org-left">An array of numeric values of type T; provides numeric operations</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgd80b02f" class="outline-4">
<h4 id="orgd80b02f"><span class="section-number-4">11.2.1.</span> array</h4>
<div class="outline-text-4" id="text-11-2-1">
<p>
An array, defined in <code>&lt;array&gt;</code>, is a fixed-size sequence of elements of a given type
where <b>the number of elements is specified at compile time</b>.
</p>

<p>
Thus, an array can be allocated with its elements on the stack,
in an object, or in static storage.
</p>

<p>
There is no overhead (time or space) involved in using an array
compared to using a built-in array.
</p>

<p>
An array knows its size, can be copied (using = or initialization),
and saves one from surprising nasty conversions to pointers.
</p>

<p>
An array does not "handle to elements."
</p>

<p>
The element count is not optional:
</p>
<div class="org-src-container">
<pre class="src src-c++">  array&lt;int&gt; ax = {1, 2, 3};
</pre>
</div>

<p>
an array can be explicitly passed to a C-style function that expects a pointer:
</p>
<div class="org-src-container">
<pre class="src src-c++">  void f(int∗ p, int sz); // C-style interface
  void g() {
    array&lt;int, 10&gt; a;
    f(a, a.size());                         // error: no conversion
    f(&amp;a[0], a.size());                     // C-style use
    f(a.data(), a.size());                  // C-style use
    auto p = find(a.begin(), a.end(), 777); // C++/STL-style use
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-org70f35d5" class="outline-4">
<h4 id="org70f35d5"><span class="section-number-4">11.2.2.</span> bitset</h4>
<div class="outline-text-4" id="text-11-2-2">
<p>
A <code>bitset</code> can be initialized with an integer or a string:
</p>
<div class="org-src-container">
<pre class="src src-c++">  bitset&lt;9&gt; bs1{"110001111"};
  bitset&lt;9&gt; bs2{399};
  bitset&lt;9&gt; bs3 =  ̃bs1;
  bitset&lt;9&gt; bs4 = bs1 &amp; bs3;
  bitset&lt;9&gt; bs5 = bs1 &lt;&lt; 2;
</pre>
</div>

<p>
<code>to_ullong()</code> and <code>to_string()</code> provide the inverse operations to the constructors.
</p>
</div>
</div>

<div id="outline-container-org9239e64" class="outline-4">
<h4 id="org9239e64"><span class="section-number-4">11.2.3.</span> pair and tuple</h4>
<div class="outline-text-4" id="text-11-2-3">
<p>
The make_pair() / make_tuple() function makes it easy to create
a pair / tuple without explicitly mentioning its type.
</p>

<p>
Elements of tuple can be accessed by <code>get&lt;0&gt;(t), get&lt;1&gt;(t), get&lt;2&gt;(t)</code>.
</p>
</div>
</div>

<div id="outline-container-org8025e1e" class="outline-4">
<h4 id="org8025e1e"><span class="section-number-4">11.2.4.</span> Time</h4>
<div class="outline-text-4" id="text-11-2-4">
<p>
The standard-library facilities for dealing with time
are found in the subnamespace <code>std::chrono</code> in <code>&lt;chrono&gt;</code>.
</p>

<p>
Timing something:
</p>
<div class="org-src-container">
<pre class="src src-c++">  using namespace std::chrono;
  auto t0 = high_resolution_clock::now();
  do_work();
  auto t1 = high_resolution_clock::now();
  cout &lt;&lt; duration_cast&lt;milliseconds&gt;(t1−t0).count() &lt;&lt; "msec\n";
</pre>
</div>
</div>
</div>

<div id="outline-container-org75c9107" class="outline-4">
<h4 id="org75c9107"><span class="section-number-4">11.2.5.</span> Function</h4>
<div class="outline-text-4" id="text-11-2-5">
<p>
A function adaptor takes a function as argument and returns a function object
that can be used to invoke the original function.
</p>

<p>
The standard library provides <code>bind()</code> and <code>mem_fn()</code> adaptors to do argument binding,
also called <i>Currying</i> or <i>partial evaluation</i>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  #include&lt;functional&gt;
  void f(int, const string &amp;);
  auto g = bind(f, 2, placeholders::_1); // bind f()’s first argument to 2
  f(2, "hello");
  g("hello");
</pre>
</div>

<p>
Use <code>mem_fn()</code> to create function objects that can invoke a member function
when called using the traditional function call notation.
</p>
<div class="org-src-container">
<pre class="src src-c++">  p−&gt; draw();
  auto draw = mem_fn(&amp;Shape::draw);
  draw(p);

  for_each(v.begin(), v.end(), mem_fn(&amp;Shape::draw));
</pre>
</div>

<p>
Often, a lambda is an alternative to using <code>bind()</code> or <code>mem_fn()</code>.
</p>

<p>
A <code>function</code> is specified with a specific return type and a specific argument type:
</p>
<div class="org-src-container">
<pre class="src src-c++">  int f1(double);
  function&lt;int(double)&gt; fct{f1}; // initialize to f1

  void user() {
    fct = [](double d) { return round(d); }; // assign lambda to fct
    fct = f1;                                // assign function to fct
  }
</pre>
</div>

<p>
Use function when you need to store something that can be called.
</p>

<p>
A type function is a function that is evaluated at compile-time
given a type as its argument or returning a type.
</p>
<div class="org-src-container">
<pre class="src src-c++">  #include &lt;limits&gt;
  constexpr float min = numeric_limits&lt;float&gt;::min(); // smallest positive float
</pre>
</div>

<p>
Metaprogramming or (when templates are involved) template metaprogramming.
</p>

<p>
<code>iterator_trait</code>, tag dispatch, type predicates.
</p>

<p>
<code>&lt;type_traits&gt;</code> : is_arithmetic, is_class, is_pod, is_literal_type,
has_virtual_destructor, and is_base_of.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org04a31e7" class="outline-2">
<h2 id="org04a31e7"><span class="section-number-2">12.</span> Numerics</h2>
<div class="outline-text-2" id="text-12">
<p>
<code>&lt;math&gt;</code> for float, double, long double :
abs(x), ceil(x), floor(x), sqrt(x), cos(x), sin(x),
tan(x), acos(x), asin(x), sinh(x), cosh(x), tanh(x),
exp(x), log(x).
</p>

<p>
The versions for <code>complex</code> are found in <code>&lt;complex&gt;</code>.
</p>

<p>
Errors are reported by setting errno from <code>&lt;cerrno&gt;</code> to <code>EDOM</code>
for a domain error and to <code>ERANGE</code> for a range error:
</p>
<div class="org-src-container">
<pre class="src src-c++">  errno = 0; // clear old error state
  // ...
  if (errno == EDOM) cerr &lt;&lt; "domain error";
  if (errno == ERANGE) cerr &lt;&lt; "range error";
</pre>
</div>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Numerical Algorithms in <code>&lt;numeric&gt;</code></caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">x=accumulate(b,e,i)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">x=accumulate(b,e,i,f)</td>
<td class="org-left">using f instead of +</td>
</tr>

<tr>
<td class="org-left">x=inner_product(b,e,b2,i)</td>
<td class="org-left">inner product of [b:e) and [b2:b2+(e−b)), i is initial value</td>
</tr>

<tr>
<td class="org-left">x=inner_product(b,e,b2,i,f,f2)</td>
<td class="org-left">using f and f2 instead of + and *</td>
</tr>

<tr>
<td class="org-left">p=partial_sum(b,e,out)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=partial_sum(b,e,out,f)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=adjacent_difference(b,e,out)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=adjacent_difference(b,e,out,f)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">iota(b,e,v)</td>
<td class="org-left">For each element in [b:e) assign ++v: v+1, v+2, &#x2026;</td>
</tr>
</tbody>
</table>

<p>
A random number generator consists of two parts:
</p>
<ol class="org-ol">
<li>an <b>engine</b> that produces a sequence of random or pseudo-random values.</li>
<li>a <b>distribution</b> that maps those values into a mathematical distribution in a range.</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++">  auto die = bind(uniform_int_distribution&lt;&gt;{1, 6},
                  default_random_engine{});
  int x = die();
</pre>
</div>

<p>
<code>valarray</code> in <code>&lt;valarray&gt;</code>  is less general and
more amenable to <b>optimization for numerical computation</b>.
</p>

<p>
Properties of numeric types are accessible through numeric_limits.
Use numeric_limits to check that the numeric types are adequate for their use.
</p>
</div>
</div>

<div id="outline-container-org92a1b7a" class="outline-2">
<h2 id="org92a1b7a"><span class="section-number-2">13.</span> Concurrency</h2>
<div class="outline-text-2" id="text-13">
<p>
threads, mutexes, lock() operations, packaged_tasks, and futures.
</p>

<p>
<b>task</b> s a computation that can potentially be executed concurrently with other computations.
A <b>thread</b> is the system-level representation of a task in a program.
</p>

<p>
A task is a function or a function object and launched as argument
by constructing a <code>std::thread</code> (found in <code>&lt;thread&gt;</code>).
</p>

<div class="org-src-container">
<pre class="src src-c++">  void f();  // function
  struct F { // function object
    void operator()();
  };
  void user() {
    thread t1{f};
    thread t2{F()};
    t1.join(); // wait for t1
    t2.join(); // wait for t2
  }
</pre>
</div>

<p>
To <code>join</code> a thread means to wait for the thread to terminate.
</p>

<p>
Threads of a program <b>share a single address space</b>.
In this, threads differ from processes, which generally do not directly share data.
Since threads share an address space, they can communicate through shared objects.
</p>

<p>
The <code>ref()</code> is a type function from <code>&lt;functional&gt;</code> that unfortunately is needed
to tell the variadic template to treat some_vec as a reference,
rather than as an object.
</p>
<div class="org-src-container">
<pre class="src src-c++">  void f(vector&lt;double&gt; &amp;v);
  thread t1{f, ref(some_vec)};
</pre>
</div>

<p>
pass the input data by const reference and to
pass the location of a place to deposit the result as a separate argument:
</p>
<div class="org-src-container">
<pre class="src src-c++">  void f(const vector&lt;double&gt; &amp;v, double *res);
  thread t1{f, cref(some_vec), &amp;res1};
</pre>
</div>
<p>
<code>cref</code> is for <code>const</code>.
</p>

<p>
A <code>mutex</code> in <code>&lt;mutex&gt;</code> is a mutual exclusion object.
A thread acquires a mutex using a <code>lock()</code> operation:
</p>
<div class="org-src-container">
<pre class="src src-c++">  mutex m;
  int sh;
  void f() {
    unique_lock&lt;mutex&gt; lck{m};
    sh += 7;
  } // release mutex implicitly
</pre>
</div>
<p>
The <code>unique_lock</code> releases the mutex with a call <code>m.unlock()</code>.
</p>

<p>
Acquiring several locks simultaneously to avoid deadlock:
</p>
<div class="org-src-container">
<pre class="src src-c++">  unique_lock&lt;mutex&gt; lck1 {m1,defer_lock};
  unique_lock&lt;mutex&gt; lck2 {m2,defer_lock};
  unique_lock&lt;mutex&gt; lck3 {m3,defer_lock};
  // ...
  lock(lck1,lck2,lck3);
</pre>
</div>

<p>
Sleep:
</p>
<div class="org-src-container">
<pre class="src src-c++">  using namespace std::chrono;
  this_thread::sleep_for(milliseconds{20});
</pre>
</div>

<p>
The basic support for communicating using external events
is provided by condition_variables found in <code>&lt;condition_variable&gt;</code>.
A <code>condition_variable</code> is a mechanism allowing one thread to wait for another:
</p>
<div class="org-src-container">
<pre class="src src-c++">  queue&lt;Message&gt; mqueue;
  condition_variable mcond;
  mutex mmutex;

  void consumer() {
    while (true) {
      unique_lock&lt;mutex&gt; lck{mmutex};
      while (mcond.wait(lck))
        /* do nothing */;
      auto m = mqueue.front();
      mqueue.pop();
      lck.unlock();
      // process m...
    }
  }
  void producer() {
    while (true) {
      Message m;
      // ... fill the message ...
      unique_lock&lt;mutex&gt; lck{mmutex};
      mqueue.push(m);
      mcond.notify_one();
    }
  }
</pre>
</div>

<p>
<code>&lt;future&gt;</code>:
</p>
<ol class="org-ol">
<li>future and promise</li>
<li>packaged_task</li>
<li>async()</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++">  void f(promise&lt;X&gt; &amp;px) {
    try {
      X res; // ...
      px.set_value(res);
    } catch (...) {
      px.set_exception(current_exception()); // pass the exception
    }
  }
  void g(future&lt;X&gt; &amp;fx) { X v = fx.get(); /* block */ }
</pre>
</div>

<p>
The packaged_task type is provided to simplify setting up tasks
connected with futures and promises to be run on threads:
</p>
<div class="org-src-container">
<pre class="src src-c++">  double accum(double∗ beg, double∗ end, double init) {
    return accumulate(beg, end, init);
  }
  double sum(vector&lt;double&gt;&amp; v) {
    using Task_type = double(double∗, double∗, double); // accumulate
    packaged_task&lt;Task_type&gt; pt0{accum};
    packaged_task&lt;Task_type&gt; pt1{accum};
    future&lt;double&gt; f0{pt0.get_future()};
    future&lt;double&gt; f1{pt1.get_future()};

    double∗ first = &amp;v[0];
    thread t1{move(pt0), first, first + v.size() / 2, 0};
    thread t2{move(pt1), first + v.size() / 2, first + v.size(), 0};
    return f0.get() + f1.get();
  }
</pre>
</div>

<p>
Using <code>async()</code>, you don’t have to think about threads and locks.
Instead, you think just in terms of tasks that potentially compute their results asynchronously:
</p>
<div class="org-src-container">
<pre class="src src-c++">  auto v0 = &amp;v[0]; auto sz = v.size();
  auto f0 = async(accum, v0, v0 + sz / 4, 0.0);
  auto f1 = async(accum, v0 + sz / 4, v0 + sz / 2, 0.0);
  auto f2 = async(accum, v0 + sz / 2, v0 + sz∗3 / 4, 0.0);
  auto f3 = async(accum, v0 + sz∗3 / 4, v0 + sz, 0.0);
  // f0.get() + f1.get() + f2.get() + f3.get();
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: scturtle</p>
<p class="date">Created: 2023-06-14 Wed 17:59</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>