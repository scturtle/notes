<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-06-14 Wed 18:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Note of "A Tour of C++"</title>
<meta name="author" content="scturtle" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="org.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Note of "A Tour of C++"</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1b27064">1. The Basics</a></li>
<li><a href="#orga29411f">2. User-Defined Types</a></li>
<li><a href="#org3082419">3. Modularity</a></li>
<li><a href="#orge5f7864">4. Classes</a>
<ul>
<li><a href="#orgfe1d4a6">4.1. Dynamic Casting</a></li>
<li><a href="#orgb92f08e">4.2. Copy and Move</a></li>
<li><a href="#org358acfc">4.3. Essential Operations</a></li>
</ul>
</li>
<li><a href="#org6fd399f">5. Templates</a></li>
<li><a href="#org1720a7b">6. Library Overview</a></li>
<li><a href="#org68c6c83">7. Strings and Regular Expressions</a>
<ul>
<li><a href="#orgafd6020">7.1. Regular Expressions</a></li>
</ul>
</li>
<li><a href="#org69c0fa2">8. I/O Streams</a></li>
<li><a href="#org7175607">9. Containers</a></li>
<li><a href="#org42e75f7">10. Algorithms</a></li>
<li><a href="#org79d1d41">11. Utilities</a>
<ul>
<li><a href="#orga8483d7">11.1. Smart Pointers</a></li>
<li><a href="#org7a54d3b">11.2. Specialized Containers</a></li>
</ul>
</li>
<li><a href="#org63659fe">12. Numerics</a></li>
<li><a href="#org72b2de8">13. Concurrency</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1b27064" class="outline-2">
<h2 id="org1b27064"><span class="section-number-2">1.</span> The Basics</h2>
<div class="outline-text-2" id="text-1">
<p>
The minimal C++ program:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #6434A3;">int</span> <span style="color: #006699;">main</span>() { }
</pre>
</div>

<p>
If no value is returned, the system will receive a value
indicating successful completion.
</p>

<p>
A function declaration may contain argument names.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #6434A3;">double</span> <span style="color: #006699;">square</span>(<span style="color: #6434A3;">double</span>); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">return the square of the argument</span>
</pre>
</div>

<p>
If two functions are defined with the same name,
 but with different argument types,
 the compiler will choose the most appropriate function to invoke for each call.
</p>

<p>
Fundamental types: bool, char, int, double, unsigned.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-right">sizeof</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bool, char</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-right">8</td>
</tr>
</tbody>
</table>

<p>
<i>The usual arithmetic conversions: expressions
 are computed at the highest precision of its operands.</i>
</p>

<p>
Universal form based on curly-brace-delimited initializer lists:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">d2</span> {2.3};
  <span style="color: #6434A3;">complex</span>&lt;<span style="color: #6434A3;">double</span>&gt; <span style="color: #BA36A5;">z3</span> = {1,2}; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">the = is optional with { ... }</span>
</pre>
</div>

<p>
<code>auto</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">b</span> = <span style="color: #D0372D;">true</span>;
</pre>
</div>

<p>
<i>Range-for-statement</i>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">v</span>[] = {0,1,2,3,4,5,6,7,8,9};
<span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">auto</span>&amp; <span style="color: #BA36A5;">x</span> : v) cout &lt;&lt; x &lt;&lt; <span style="color: #008000;">'\n'</span>;
</pre>
</div>

<p>
Use <code>nullptr</code> rather than <code>0</code> or <code>NULL</code>.
</p>

<p>
Prefer the <code>{}</code>-initializer syntax for declarations with a named type,
prefer the <code>=</code> syntax for the initialization in declarations using <code>auto</code>.
</p>
</div>
</div>

<div id="outline-container-orga29411f" class="outline-2">
<h2 id="orga29411f"><span class="section-number-2">2.</span> User-Defined Types</h2>
<div class="outline-text-2" id="text-2">
<p>
A <code>struct</code> is simply a class with members public by default:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">V</span>{ <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">val</span>; };
</pre>
</div>

<p>
Class:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Vector</span> {
  <span style="color: #0000FF;">public</span>:
    <span style="color: #006699;">Vector</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">s</span>) : elem{<span style="color: #0000FF;">new</span> <span style="color: #6434A3;">double</span>[s]}, sz{s} {} <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">member initializer list</span>
    <span style="color: #6434A3;">double</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">[]</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>) { <span style="color: #0000FF;">return</span> elem[i]; } <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">operation</span>
    <span style="color: #6434A3;">int</span> <span style="color: #006699;">size</span>() { <span style="color: #0000FF;">return</span> sz; }

  <span style="color: #0000FF;">private</span>:
    <span style="color: #6434A3;">double</span>* <span style="color: #BA36A5;">elem</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">sz</span>;
  };
</pre>
</div>

<p>
A <code>union</code> is a <code>struct</code> in which all members are allocated at the same address
so that the <code>union</code> occupies only as much space as its largest member.
Naturally, a <code>union</code> can hold a value for only one member at a time.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">union</span> <span style="color: #6434A3;">Value</span> {
    <span style="color: #6434A3;">char</span>* <span style="color: #BA36A5;">s</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>;
  };
</pre>
</div>


<p>
Enumeration:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #0000FF;">enum</span> <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Color</span> { <span style="color: #BA36A5;">red</span>, <span style="color: #BA36A5;">blue</span>, <span style="color: #BA36A5;">green</span> };
<span style="color: #6434A3;">Color</span> <span style="color: #BA36A5;">col</span> = <span style="color: #D0372D;">Color</span>::red;
</pre>
</div>

<p>
An enumeration is a user-defined type so we can define operators for it.
You can remove the <code>class</code> from <code>enum</code> class to get a plain <code>enum</code>
(<code>int</code> value starts with 0).
</p>
</div>
</div>

<div id="outline-container-org3082419" class="outline-2">
<h2 id="org3082419"><span class="section-number-2">3.</span> Modularity</h2>
<div class="outline-text-2" id="text-3">
<p>
Declarations / interfaces, <code>Vector.h</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Vector</span> {
  <span style="color: #0000FF;">public</span>:
    <span style="color: #006699;">Vector</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">s</span>);
    <span style="color: #6434A3;">double</span>&amp; <span style="color: #0000FF;">operator</span><span style="color: #006699;">[]</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>);
    <span style="color: #6434A3;">int</span> <span style="color: #006699;">size</span>();
  <span style="color: #0000FF;">private</span>:
    <span style="color: #6434A3;">double</span>* <span style="color: #BA36A5;">elem</span>;
  };
</pre>
</div>

<p>
Avoid non-inline function definitions in headers.
</p>

<p>
Definitions / implementations, <code>Vector.cpp</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #808080; font-weight: bold;">  #include</span> <span style="color: #008000;">"Vector.h"</span>
  <span style="color: #D0372D;">Vector</span>::<span style="color: #006699;">Vector</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">s</span>) :elem{<span style="color: #0000FF;">new</span> <span style="color: #6434A3;">double</span>[s]}, sz{s} { }
  <span style="color: #6434A3;">double</span>&amp; <span style="color: #D0372D;">Vector</span>::<span style="color: #0000FF;">operator</span>[](<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>) { <span style="color: #0000FF;">return</span> elem[i]; }
  <span style="color: #6434A3;">int</span> <span style="color: #D0372D;">Vector</span>::<span style="color: #006699;">size</span>() { <span style="color: #0000FF;">return</span> sz; }
</pre>
</div>

<p>
Namespaces:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">namespace</span> <span style="color: #D0372D;">My_code</span> {
    <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">complex</span> {
      <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
    };
    <span style="color: #6434A3;">complex</span> <span style="color: #006699;">sqrt</span>(<span style="color: #6434A3;">complex</span>);
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
    <span style="color: #6434A3;">int</span> <span style="color: #006699;">main</span>();
  }
  <span style="color: #6434A3;">int</span> <span style="color: #D0372D;">My_code</span>::<span style="color: #006699;">main</span>(){
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  };
</pre>
</div>

<p>
Don't put a using-directive in a header file.
</p>

<p>
Exceptions:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #808080; font-weight: bold;">  #include</span><span style="color: #008000;">&lt;stdexcept&gt;</span>
  <span style="color: #0000FF;">throw</span> out_of_range{<span style="color: #008000;">"Vector::operator[]"</span>};

  <span style="color: #0000FF;">try</span> { <span style="color: #8D8D84; font-style: italic;">/* </span><span style="color: #8D8D84; font-style: italic;">...</span><span style="color: #8D8D84; font-style: italic;"> */</span> }
  <span style="color: #0000FF;">catch</span> (out_of_range) { <span style="color: #8D8D84; font-style: italic;">/* </span><span style="color: #8D8D84; font-style: italic;">...</span><span style="color: #8D8D84; font-style: italic;"> */</span> }
  <span style="color: #0000FF;">catch</span> (...) { <span style="color: #8D8D84; font-style: italic;">/* </span><span style="color: #8D8D84; font-style: italic;">any exception</span><span style="color: #8D8D84; font-style: italic;"> */</span> }
</pre>
</div>

<p>
Logic errors: <code>logic_error</code>, <code>domain_error</code>, <code>invalid_argument</code>, <code>length_error</code>, <code>out_of_range</code>.
</p>

<p>
Runtime errors: <code>runtime_error</code>, <code>range_error</code>, <code>overflow_error</code>, <code>underflow_error</code>.
</p>

<p>
A function that should never throw an exception can be declared noexcept:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #6434A3;">void</span> <span style="color: #006699;">user</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">sz</span>) <span style="color: #0000FF;">noexcept</span>;
</pre>
</div>

<p>
If still throws, the standard-library function <code>terminate()</code>
 is called to immediately terminate the program.
</p>

<p>
If operator <code>new</code> can't find memory to allocate, it throws a <code>std::bad_alloc</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">try</span> { <span style="color: #8D8D84; font-style: italic;">/* </span><span style="color: #8D8D84; font-style: italic;">...</span><span style="color: #8D8D84; font-style: italic;"> */</span> }
  <span style="color: #0000FF;">catch</span> (<span style="color: #D0372D;">std</span>::bad_alloc) {
    <span style="color: #D0372D;">std</span>::terminate(); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">handle memory exhaustion</span>
  }
</pre>
</div>

<p>
To rethrow the exception, we simply write <code>throw</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">catch</span> (<span style="color: #D0372D;">std</span>::length_error) {
    cout &lt;&lt; <span style="color: #008000;">"test failed: length error\n"</span>;
    <span style="color: #0000FF;">throw</span>; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">rethrow</span>
  }
</pre>
</div>

<p>
Compile time check:
</p>
<div class="org-src-container">
<pre class="src src-c++">  static_assert(4 &lt;= <span style="color: #0000FF;">sizeof</span>(<span style="color: #6434A3;">int</span>), <span style="color: #008000;">"integers are too small"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orge5f7864" class="outline-2">
<h2 id="orge5f7864"><span class="section-number-2">4.</span> Classes</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>const</code> function:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">double</span> <span style="color: #006699;">real</span>() <span style="color: #0000FF;">const</span> { <span style="color: #0000FF;">return</span> re; }
</pre>
</div>

<p>
Operations change object itself should return reference:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">complex</span>&amp; <span style="color: #0000FF;">operator</span><span style="color: #006699;">+=</span>(<span style="color: #6434A3;">complex</span> <span style="color: #BA36A5;">z</span>) { re+=z.re, im+=z.im; <span style="color: #0000FF;">return</span> *<span style="color: #0000FF;">this</span>; }
</pre>
</div>

<p>
Functions defined in a class are inlined by default.
It is possible to explicitly require inlining by
preceeding a function declaration with the keyword <code>inline</code>.
</p>

<p>
Clever ways of implementing operations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  complex <span style="color: #0000FF;">operator</span>&#8722;(<span style="color: #6434A3;">complex</span> <span style="color: #BA36A5;">a</span>, complex b) { <span style="color: #0000FF;">return</span> a &#8722;= b; }
  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">unary minus</span>
  complex <span style="color: #0000FF;">operator</span>&#8722;(complex a) { <span style="color: #0000FF;">return</span> {&#8722;a.real(), &#8722;a.imag()}; }
</pre>
</div>

<p>
Destructor:
</p>
<div class="org-src-container">
<pre class="src src-c++">  ~<span style="color: #006699;">Vector</span>() { <span style="color: #0000FF;">delete</span>[] elem; }
</pre>
</div>

<p>
Initializer-list constructor:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #D0372D;">Vector</span>::<span style="color: #006699;">Vector</span>(<span style="color: #D0372D;">std</span>::<span style="color: #6434A3;">initializer_list</span>&lt;<span style="color: #6434A3;">double</span>&gt; <span style="color: #BA36A5;">lst</span>)
      : elem{<span style="color: #0000FF;">new</span> <span style="color: #6434A3;">double</span>[lst.size()]}, sz{<span style="color: #0000FF;">static_cast</span>&lt;<span style="color: #6434A3;">int</span>&gt;(lst.size())} {
    copy(lst.begin(), lst.end(), elem);
  }
</pre>
</div>

<p>
<code>push_back</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">Vector</span> <span style="color: #006699;">read</span>(<span style="color: #6434A3;">istream</span> &amp;<span style="color: #BA36A5;">is</span>) {
    <span style="color: #6434A3;">Vector</span> <span style="color: #BA36A5;">v</span>;
    <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">d</span>; is &gt;&gt; d;)
      v.push_back(d);
    <span style="color: #0000FF;">return</span> v;
  }
</pre>
</div>

<p>
Abstract type:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Container</span> {
  <span style="color: #0000FF;">public</span>:
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">pure virtual function</span>
    <span style="color: #0000FF;">virtual</span> <span style="color: #6434A3;">double</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">[]</span>(<span style="color: #6434A3;">int</span>) = 0;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">const member function</span>
    <span style="color: #0000FF;">virtual</span> <span style="color: #6434A3;">int</span> <span style="color: #006699;">size</span>() <span style="color: #0000FF;">const</span> = 0;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">destructor</span>
    <span style="color: #0000FF;">virtual</span>  ~<span style="color: #006699;">Container</span>() {}
  };
</pre>
</div>

<p>
The word <code>virtual</code> means "may be redefined later in a class derived from this one."
</p>

<p>
The curious <code>=0</code> syntax says the function is pure virtual;
that is, some class derived from <code>Container</code> <b>must</b> define the function.
</p>

<p>
A class with a pure virtual function is called an abstract class
and it's not possible to define an object of it.
</p>

<p>
As is common for abstract class, it does <b>not</b> have a constructor.
On the other hand, it <b>does</b> have a destructor and that destructor is <code>virtual</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Vector_container</span> : <span style="color: #0000FF;">public</span> <span style="color: #6434A3;">Container</span> {
    <span style="color: #6434A3;">Vector</span> <span style="color: #BA36A5;">v</span>;

  <span style="color: #0000FF;">public</span>:
    <span style="color: #006699;">Vector_container</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">s</span>) : v(s) {}
    ~<span style="color: #006699;">Vector_container</span>() {}
    <span style="color: #6434A3;">double</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">[]</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>) { <span style="color: #0000FF;">return</span> v[i]; }
    <span style="color: #6434A3;">int</span> <span style="color: #006699;">size</span>() <span style="color: #0000FF;">const</span> { <span style="color: #0000FF;">return</span> v.size(); }
  };
</pre>
</div>

<p>
Note that the member destructor (<code>~Vector()</code>) is implicitly invoked
by its class's destructor (<code>~Vector_container()</code>).
</p>

<p>
Virtual function table (<code>vtbl</code>).
</p>

<p>
A function in a derived class overrides a virtual function
in a base class if that function has exactly the same name and type.
</p>

<p>
A function with a slightly different name or a slightly different type
may be intended to override or it may be intended to be a separate function.
</p>

<p>
Explicitly state that a function is meant to override:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">void</span> <span style="color: #006699;">move</span>(<span style="color: #6434A3;">Point</span> <span style="color: #BA36A5;">to</span>) <span style="color: #0000FF;">override</span>;
</pre>
</div>
</div>

<div id="outline-container-orgfe1d4a6" class="outline-3">
<h3 id="orgfe1d4a6"><span class="section-number-3">4.1.</span> Dynamic Casting</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Dynamic casting:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">if</span> (<span style="color: #6434A3;">Smiley</span>* <span style="color: #BA36A5;">p</span> = <span style="color: #0000FF;">dynamic_cast</span>&lt;<span style="color: #6434A3;">Smiley</span>*&gt;(ps)) { <span style="color: #8D8D84; font-style: italic;">/* </span><span style="color: #8D8D84; font-style: italic;">...</span><span style="color: #8D8D84; font-style: italic;"> */</span> }
</pre>
</div>
<p>
If the object pointed to by the argument of <code>dynamic_cast</code>
is not of the expected type or a class derived from the expected type,
<code>dynamic_cast</code> returns <code>nullptr</code>.
</p>

<p>
When a different type is unacceptable, we can simply <code>dynamic_cast</code> to a reference type.
If the object is not of the expected type, <code>bad_cast</code> is thrown:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">Smiley</span> &amp;<span style="color: #BA36A5;">r</span>{<span style="color: #0000FF;">dynamic_cast</span>&lt;<span style="color: #6434A3;">Smiley</span> &amp;&gt;(*ps)};
</pre>
</div>

<p>
Better resource handling: return <code>unique_ptr</code> rather than
a naked pointer and store <code>unique_ptrs</code> in the container:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">vector</span>&lt;<span style="color: #6434A3;">unique_ptr</span>&lt;Shape&gt;&gt; <span style="color: #BA36A5;">v</span>;
  v.push_back(<span style="color: #6434A3;">unique_ptr</span>&lt;Shape&gt;{<span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Circle</span>{p, r}});
</pre>
</div>

<p>
Now the object is owned by the <code>unique_ptr</code> which will delete the object
when it is no longer needed, that is, when its <code>unique_ptr</code> goes out of scope.
</p>
</div>
</div>

<div id="outline-container-orgb92f08e" class="outline-3">
<h3 id="orgb92f08e"><span class="section-number-3">4.2.</span> Copy and Move</h3>
<div class="outline-text-3" id="text-4-2">
<p>
By default, objects can be copied.
The default meaning of copy is memberwise copy: copy each member.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">complex</span> <span style="color: #BA36A5;">z2</span>{z1}; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">copy initialization</span>
  <span style="color: #6434A3;">complex</span> <span style="color: #BA36A5;">z3</span>;
  z3 = z2;        <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">copy assignment</span>
</pre>
</div>

<p>
Copy constructor and copy assignment:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Vector</span> &amp;<span style="color: #BA36A5;">a</span>);            <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">copy constructor</span>
  <span style="color: #6434A3;">Vector</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">=</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Vector</span> &amp;<span style="color: #BA36A5;">a</span>); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">copy assignment</span>

  <span style="color: #D0372D;">Vector</span>::<span style="color: #006699;">Vector</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Vector</span> &amp;<span style="color: #BA36A5;">a</span>) : elem{<span style="color: #0000FF;">new</span> <span style="color: #6434A3;">double</span>[a.sz]}, sz{a.sz} {
    <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i != sz; ++i)
      elem[i] = a.elem[i];
  }

  <span style="color: #6434A3;">Vector</span> &amp;<span style="color: #D0372D;">Vector</span>::<span style="color: #0000FF;">operator</span>=(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Vector</span> &amp;<span style="color: #BA36A5;">a</span>) {
    <span style="color: #6434A3;">double</span>* <span style="color: #BA36A5;">p</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">double</span>[a.sz];
    <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i != a.sz; ++i)
      p[i] = a.elem[i];
    <span style="color: #0000FF;">delete</span>[] elem; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">delete old elements</span>
    elem = p;
    sz = a.sz;
    <span style="color: #0000FF;">return</span> *<span style="color: #0000FF;">this</span>;
  }
</pre>
</div>

<p>
To avoid copying in returning value:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">Vector</span> <span style="color: #006699;">foo</span>(<span style="color: #8D8D84; font-style: italic;">/* </span><span style="color: #8D8D84; font-style: italic;">...</span><span style="color: #8D8D84; font-style: italic;"> */</span>) {
    <span style="color: #6434A3;">Vector</span> <span style="color: #BA36A5;">res</span>;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
    <span style="color: #0000FF;">return</span> res;
  }

</pre>
</div>

<p>
Move constructor and move assignment should be implemented:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector(<span style="color: #6434A3;">Vector</span> &amp;&amp;<span style="color: #BA36A5;">a</span>);            <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">move constructor</span>
  <span style="color: #6434A3;">Vector</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">=</span>(<span style="color: #6434A3;">Vector</span> &amp;&amp;<span style="color: #BA36A5;">a</span>); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">move assignment</span>

  <span style="color: #D0372D;">Vector</span>::<span style="color: #006699;">Vector</span>(<span style="color: #6434A3;">Vector</span> &amp;&amp;<span style="color: #BA36A5;">a</span>)
      : elem{a.elem}, sz{a.sz} { <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">"grab the elements" from a</span>
    a.elem = <span style="color: #D0372D;">nullptr</span>; a.sz = 0;  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">now a has no elements</span>
  }
</pre>
</div>

<p>
The <code>&amp;&amp;</code> means <i>rvalue</i> reference and is a reference to which we can bind an rvalue.
The word "rvalue" is intended to complement "lvalue," which roughly means
"something that can appear on the left-hand side of an assignment."
So an <b>rvalue</b> is – to a first approximation – <b>a value that you can't assign to</b>,
such as an integer returned by a function call.
Thus, an rvalue reference is a reference to something that nobody else can assign to,
so that we can safely "steal" its value.
</p>

<p>
A move operation is applied when an rvalue reference is used
as an initializer or as the right-hand side of an assignment.
</p>

<p>
Manually move with <code>std::move</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">Vector</span> <span style="color: #006699;">f</span>() {
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
    z = x;            <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">we get a copy</span>
    y = <span style="color: #D0372D;">std</span>::move(x); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">we get a move</span>
    <span style="color: #0000FF;">return</span> z;         <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">we get a move</span>
  }
</pre>
</div>
</div>
</div>


<div id="outline-container-org358acfc" class="outline-3">
<h3 id="org358acfc"><span class="section-number-3">4.3.</span> Essential Operations</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">X</span> {
  <span style="color: #0000FF;">public</span>:
    X(Sometype);             <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">ordinary constructor: create an object</span>
    <span style="color: #006699;">X</span>();                     <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">default constructor</span>
    <span style="color: #006699;">X</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">X</span> &amp;);            <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">copy constructor</span>
    <span style="color: #006699;">X</span>(<span style="color: #6434A3;">X</span> &amp;&amp;);                 <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">move constructor</span>
    <span style="color: #6434A3;">X</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">=</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">X</span> &amp;); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">copy assignment: clean up target and copy</span>
    <span style="color: #6434A3;">X</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">=</span>(<span style="color: #6434A3;">X</span> &amp;&amp;);      <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">move assignment: clean up target and move</span>
    ~<span style="color: #006699;">X</span>();                    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">destructor: clean up</span>
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  };
</pre>
</div>

<p>
Except for the ordinary constructor, these can be generated by compiler:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Y</span> {
  <span style="color: #0000FF;">public</span>:
    Y(Sometype);
    <span style="color: #006699;">Y</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Y</span> &amp;) = <span style="color: #0000FF;">default</span>; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">I really want the default copy constructor</span>
    <span style="color: #006699;">Y</span>(<span style="color: #6434A3;">Y</span> &amp;&amp;) = <span style="color: #0000FF;">default</span>;      <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">I really want the default copy constructor</span>
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  };
</pre>
</div>

<p>
If you are explicit about some defaults,
other default definitions will not be generated.
</p>

<p>
Eliminate the default definitions of those two operations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Shape</span> {
  <span style="color: #0000FF;">public</span>:
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">no copy operations</span>
    <span style="color: #006699;">Shape</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Shape</span> &amp;) = <span style="color: #0000FF;">delete</span>;
    <span style="color: #6434A3;">Shape</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">=</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Shape</span> &amp;) = <span style="color: #0000FF;">delete</span>;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">no move operations</span>
    <span style="color: #006699;">Shape</span>(<span style="color: #6434A3;">Shape</span> &amp;&amp;) = <span style="color: #0000FF;">delete</span>;
    <span style="color: #6434A3;">Shape</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">=</span>(<span style="color: #6434A3;">Shape</span> &amp;&amp;) = <span style="color: #0000FF;">delete</span>;
    ~<span style="color: #006699;">Shape</span>();
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  };
</pre>
</div>

<p>
A constructor taking a single argument defines a conversion from its argument type,
but if only <code>explicit</code> conversion is allowed:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Vector</span> {
  <span style="color: #0000FF;">public</span>:
    <span style="color: #0000FF;">explicit</span> <span style="color: #006699;">Vector</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">s</span>); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">no implicit conversion from int to Vector</span>
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  };
</pre>
</div>

<p>
<i>C++ also offers a garbage collection interface
 so that you can plug in a garbage collector.</i>
</p>

<p>
In the C++ standard library, RAII (Resource Acquisition Is Initialization) is pervasive:
 for example, memory (string, vector, map, <code>unordered_map</code>, etc.),
 files (ifstream, ofstream, etc.), threads (thread), locks (<code>lock_guard</code>, <code>unique_lock</code>, etc.),
 and general objects (through <code>unique_ptr</code> and <code>shared_ptr</code>).
</p>
</div>
</div>
</div>

<div id="outline-container-org6fd399f" class="outline-2">
<h2 id="org6fd399f"><span class="section-number-2">5.</span> Templates</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">template</span>&lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">T</span>&gt;
  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Vector</span> {
  <span style="color: #0000FF;">private</span>:
    <span style="color: #6434A3;">T</span>* <span style="color: #BA36A5;">elem</span>;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  }
  <span style="color: #D0372D;">Vector</span>&lt;<span style="color: #6434A3;">T</span>&gt;::<span style="color: #006699;">Vector</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">s</span>) { <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
</pre>
</div>

<p>
Using <code>class</code> to introduce a type parameter is equivalent to using <code>typename</code>,
and in older code we often see <code>template&lt;class T&gt;</code> as the prefix.
</p>

<p>
The <code>&gt;&gt;</code> in <code>Vector&lt;list&lt;int&gt;&gt;</code> terminates the nested template arguments;
it is not a misplaced input operator.
It is not (as in C++98) necessary to place a space between the two &gt;s.
</p>

<p>
Provide <code>begin()</code> and <code>end()</code> to support <code>range-for</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">template</span> &lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">T</span>&gt;
  <span style="color: #6434A3;">T</span> *<span style="color: #006699;">begin</span>(<span style="color: #6434A3;">Vector</span>&lt;<span style="color: #6434A3;">T</span>&gt; &amp;<span style="color: #BA36A5;">x</span>) {
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">pointer to first element or nullptr</span>
    <span style="color: #0000FF;">return</span> x.size() ? &amp;x[0] : <span style="color: #D0372D;">nullptr</span>;
  }
  <span style="color: #0000FF;">template</span> &lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">T</span>&gt;
  <span style="color: #6434A3;">T</span> *<span style="color: #006699;">end</span>(<span style="color: #6434A3;">Vector</span>&lt;<span style="color: #6434A3;">T</span>&gt; &amp;<span style="color: #BA36A5;">x</span>) {
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">pointer to one-past-last element</span>
    <span style="color: #0000FF;">return</span> begin(x) + x.size();
  }
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f2</span>(<span style="color: #6434A3;">Vector</span>&lt;<span style="color: #6434A3;">string</span>&gt; &amp;<span style="color: #BA36A5;">vs</span>) {
    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">auto</span> &amp;<span style="color: #BA36A5;">s</span> : vs)
      cout &lt;&lt; s &lt;&lt; <span style="color: #008000;">'\n'</span>;
  }
</pre>
</div>

<p>
Templates are a compile-time mechanism,
so their use incurs no run-time overhead compared to hand-crafted code.
</p>

<p>
A template can take value arguments:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">template</span>&lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">T</span>, <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">N</span>&gt;
  <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">Buffer</span> {
    <span style="color: #0000FF;">using</span> <span style="color: #6434A3;">value_type</span> = T;
    <span style="color: #0000FF;">constexpr</span> <span style="color: #6434A3;">int</span> <span style="color: #006699;">size</span>() { <span style="color: #0000FF;">return</span> N; }
    T[N];
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  };
</pre>
</div>

<p>
The alias <code>value_type</code> and the <code>constexpr</code> function are provided
to allow users (read-only) access to the template arguments.
</p>

<p>
Can be used to create arbitrarily sized buffers on stack:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">Buffer</span>&lt;<span style="color: #6434A3;">char</span>,1024&gt; <span style="color: #BA36A5;">glob</span>;
</pre>
</div>

<p>
Function object: objects that can be called like functions:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">template</span>&lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">T</span>&gt;
  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Less_than</span> {
    <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">T</span> <span style="color: #BA36A5;">val</span>; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">value to compare against</span>
  <span style="color: #0000FF;">public</span>:
    <span style="color: #006699;">Less_than</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">T</span> &amp;<span style="color: #BA36A5;">v</span>) : val(v) {}
    <span style="color: #6434A3;">bool</span> <span style="color: #0000FF;">operator</span><span style="color: #006699;">()</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">T</span> &amp;<span style="color: #BA36A5;">x</span>) <span style="color: #0000FF;">const</span> { <span style="color: #0000FF;">return</span> x &lt; val; } <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">call operator</span>
  };

  count(vec, <span style="color: #6434A3;">Less_than</span>&lt;<span style="color: #6434A3;">int</span>&gt;{x});
</pre>
</div>

<p>
Lambda expression:
</p>
<div class="org-src-container">
<pre class="src src-c++">  count(vec, [&amp;](<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">a</span>) { <span style="color: #0000FF;">return</span> a &lt; x; });
</pre>
</div>

<p>
Capture nothing is <code>[ ]</code> , capture all local names used by reference is <code>[&amp;]</code> ,
 and capture all local names used by value is <code>[=]</code> .
</p>

<p>
Had we wanted to capture only x, we could have said so: <code>[&amp;x]</code> .
Had we wanted to give the generated object a copy of x,
we could have said so: <code>[=x]</code> .
</p>

<p>
Variadic templates:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f</span>() { } <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">do nothing</span>
  <span style="color: #0000FF;">template</span>&lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">T</span>, <span style="color: #0000FF;">typename</span>... <span style="color: #6434A3;">Tail</span>&gt;
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f</span>(<span style="color: #6434A3;">T</span> <span style="color: #BA36A5;">head</span>, <span style="color: #6434A3;">Tail</span>... <span style="color: #BA36A5;">tail</span>) {
    g(head);    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">do something to head</span>
    f(tail...); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">try again with tail</span>
  }
</pre>
</div>

<p>
Another example in chapter 11:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">template</span> &lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">T</span>, <span style="color: #0000FF;">typename</span>... <span style="color: #6434A3;">Args</span>&gt;
  <span style="color: #6434A3;">unique_ptr</span>&lt;<span style="color: #6434A3;">T</span>&gt; <span style="color: #006699;">make_unique</span>(<span style="color: #6434A3;">Args</span> &amp;&amp;... <span style="color: #BA36A5;">args</span>) {
    <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">std</span>::<span style="color: #6434A3;">unique_ptr</span>&lt;<span style="color: #6434A3;">T</span>&gt;{<span style="color: #0000FF;">new</span> <span style="color: #6434A3;">T</span>{<span style="color: #D0372D;">std</span>::forward&lt;<span style="color: #6434A3;">Args</span>&gt;(args)...}};
  }
</pre>
</div>

<p>
Aliases:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">in &lt;cstddef&gt;</span>
  <span style="color: #0000FF;">using</span> <span style="color: #6434A3;">size_t</span> = <span style="color: #6434A3;">unsigned</span> <span style="color: #6434A3;">int</span>;
</pre>
</div>

<p>
It is very common for a parameterized type to provide
an alias for types related to their template arguments.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">template</span>&lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">T</span>&gt;
  <span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Vector</span> {
  <span style="color: #0000FF;">public</span>:
    <span style="color: #0000FF;">using</span> <span style="color: #6434A3;">value_type</span> = T;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  };
</pre>
</div>

<p>
In fact, every standard-library container provides
<code>value_type</code> as the name of its value type.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">template</span> &lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">C</span>&gt;
  <span style="color: #0000FF;">using</span> <span style="color: #6434A3;">Element_type</span> = <span style="color: #0000FF;">typename</span> <span style="color: #D0372D;">C</span>::value_type;

  <span style="color: #0000FF;">template</span> &lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">Container</span>&gt;
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">algo</span>(<span style="color: #6434A3;">Container</span> &amp;<span style="color: #BA36A5;">c</span>) {
    <span style="color: #6434A3;">Vector</span>&lt;<span style="color: #6434A3;">Element_type</span>&lt;<span style="color: #6434A3;">Container</span>&gt;&gt; <span style="color: #BA36A5;">vec</span>;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  }
</pre>
</div>

<p>
A function template argument needs to be explicitly mentioned
only if it cannot be deduced or if there is no default:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">template</span> &lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">Target</span> = <span style="color: #6434A3;">string</span>, <span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">Source</span> = <span style="color: #6434A3;">string</span>&gt;
  <span style="color: #6434A3;">Target</span> <span style="color: #006699;">to</span>(<span style="color: #6434A3;">Source</span> <span style="color: #BA36A5;">arg</span>) {
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  }
  <span style="color: #6434A3;">int</span> <span style="color: #006699;">main</span>() {
    <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">x1</span> = to&lt;<span style="color: #6434A3;">string</span>, <span style="color: #6434A3;">double</span>&gt;(1.2);
    <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">x2</span> = to&lt;<span style="color: #6434A3;">string</span>&gt;(1.2); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">Source is deduced to double</span>
    <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">x3</span> = to&lt;&gt;(1.2);
    <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">x4</span> = to(1.2);
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-org1720a7b" class="outline-2">
<h2 id="org1720a7b"><span class="section-number-2">6.</span> Library Overview</h2>
<div class="outline-text-2" id="text-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Selected Standard Library Headers</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">header</th>
<th scope="col" class="org-left">declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&lt;string&gt;</td>
<td class="org-left">string, basic_string</td>
</tr>

<tr>
<td class="org-left">&lt;regex&gt;</td>
<td class="org-left">regex, smatch</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;fstream&gt;</td>
<td class="org-left">fstream, ifstream, ofstream</td>
</tr>

<tr>
<td class="org-left">&lt;iostream&gt;</td>
<td class="org-left">istream, ostream, cin, cout</td>
</tr>

<tr>
<td class="org-left">&lt;sstream&gt;</td>
<td class="org-left">istrstream, ostrstream</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;array&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">&lt;vector&gt;</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">&lt;set&gt;</td>
<td class="org-left">set, multiset</td>
</tr>

<tr>
<td class="org-left">&lt;map&gt;</td>
<td class="org-left">map, multimap</td>
</tr>

<tr>
<td class="org-left">&lt;unordered_map&gt;</td>
<td class="org-left">unordered_map, unordered_multimap</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;algorithm&gt;</td>
<td class="org-left">copy(), find(), sort()</td>
</tr>

<tr>
<td class="org-left">&lt;random&gt;</td>
<td class="org-left">default_random_engine, normal_distribution</td>
</tr>

<tr>
<td class="org-left">&lt;memory&gt;</td>
<td class="org-left">unique_ptr, shared_ptr, allocator</td>
</tr>

<tr>
<td class="org-left">&lt;utility&gt;</td>
<td class="org-left">move(), swap(), pair</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;cmath&gt;</td>
<td class="org-left">sqrt(), pow()</td>
</tr>

<tr>
<td class="org-left">&lt;complex&gt;</td>
<td class="org-left">complex, sqrt(), pow()</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;future&gt;</td>
<td class="org-left">future, promise</td>
</tr>

<tr>
<td class="org-left">&lt;thread&gt;</td>
<td class="org-left">thread</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;forward_list&gt;</td>
<td class="org-left">forward_list</td>
</tr>

<tr>
<td class="org-left">&lt;stdexcept&gt;</td>
<td class="org-left">length_error, out_of_range, runtime_error</td>
</tr>

<tr>
<td class="org-left">&lt;chrono&gt;</td>
<td class="org-left">duration, time_point</td>
</tr>

<tr>
<td class="org-left">&lt;ios&gt;</td>
<td class="org-left">hex,dec,scientific,fixed,defaultfloat</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org68c6c83" class="outline-2">
<h2 id="org68c6c83"><span class="section-number-2">7.</span> Strings and Regular Expressions</h2>
<div class="outline-text-2" id="text-7">
<p>
A string is mutable: <code>=</code>, <code>+=</code>, <code>[]</code>.
</p>

<p>
<code>.size()</code>, <code>.insert()</code>, <code>.erase()</code>, <code>.find()</code> (<code>string::npos</code>),
<code>.substr()</code>, <code>.replace()</code>, <code>.c_str()</code> (read-only).
</p>

<p>
<b>short-string optimization</b>: short string values are kept in the string object itself
and only longer strings are placed on free store.
</p>

<p>
<code>string</code> is really an alias for a general template <code>basic_string</code>
with the character type <code>char</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #0000FF;">using</span> <span style="color: #6434A3;">string</span> = <span style="color: #6434A3;">basic_string</span>&lt;<span style="color: #6434A3;">char</span>&gt;
</pre>
</div>

<p>
<code>wstring</code>, <code>u16string</code>, <code>u32string</code>.
</p>
</div>

<div id="outline-container-orgafd6020" class="outline-3">
<h3 id="orgafd6020"><span class="section-number-3">7.1.</span> Regular Expressions</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Pattern:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #6434A3;">regex</span> <span style="color: #006699;">pat</span> (R"<span style="color: #008000;">(\w{2}\s&#8727;\d{5}(&#8722;\d{4})?)</span>");
</pre>
</div>

<p>
<code>regex_match()</code>, <code>regex_search()</code>, <code>regex_replace()</code>, <code>regex_iterator</code>, <code>regex_token_iterator</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">lineno</span> = 0;
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">string</span> <span style="color: #BA36A5;">line</span>; getline(cin, line);) {
    ++lineno;
    <span style="color: #6434A3;">smatch</span> <span style="color: #BA36A5;">matches</span>;
    <span style="color: #0000FF;">if</span> (regex_search(line, matches, pat))
      cout &lt;&lt; lineno &lt;&lt; <span style="color: #008000;">": "</span> &lt;&lt; matches[0] &lt;&lt; <span style="color: #008000;">'\n'</span>;
  }
</pre>
</div>

<p>
An smatch is a vector of sub-matches of type string.
The first element, here <code>matches[0]</code>, is the complete match.
</p>

<p>
Sub-match:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">if</span> (1 &lt; matches.size() &amp;&amp; matches[1].matched)
    cout &lt;&lt; <span style="color: #008000;">"\t: "</span> &lt;&lt; matches[1] &lt;&lt; <span style="color: #008000;">'\n'</span>;
</pre>
</div>

<p>
Regular expressions are compiled into state machines for efficient execution.
</p>

<p>
Character classes and abbreviations (skipped here).
</p>

<p>
Iterator:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">string</span> <span style="color: #BA36A5;">input</span> = <span style="color: #008000;">"aa as; asd ++e&#710;asdf asdfg"</span>;
  <span style="color: #6434A3;">regex</span> <span style="color: #BA36A5;">pat</span>{R"<span style="color: #008000;">(\s+(\w+))</span>"};
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">sregex_iterator</span> <span style="color: #006699;">p</span>(input.begin(), input.end(), pat);
       p != sregex_iterator{}; ++p)
    cout &lt;&lt; (*p)[1] &lt;&lt; <span style="color: #008000;">'\n'</span>;
</pre>
</div>

<p>
Return strings by value (rely on move semantics).
</p>

<p>
Use a string_stream or a generic value extraction function (such as <code>to&lt;X&gt;</code>)
for numeric conversion of strings.
</p>
</div>
</div>
</div>

<div id="outline-container-org69c0fa2" class="outline-2">
<h2 id="org69c0fa2"><span class="section-number-2">8.</span> I/O Streams</h2>
<div class="outline-text-2" id="text-8">
<p>
By default, <code>&gt;&gt;</code> skips initial whitespace.
</p>

<p>
By default, a whitespace character, such as a space or a newline, terminates the read.
You can read a whole line (including the terminating newline character) using the <code>getline()</code> function.
</p>
<div class="org-src-container">
<pre class="src src-c++">getline(cin,str);
</pre>
</div>

<p>
I/O state:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">while</span> (cin &gt;&gt; i)
    res.push_back(i);

  <span style="color: #0000FF;">if</span> (cin.eof()) {
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  } <span style="color: #0000FF;">else</span> <span style="color: #0000FF;">if</span> (cin.fail()) { <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">a potentially recoverable error</span>
    cin.clear();           <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">reset the state to good()</span>
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">if fail again</span>
    cin.setstate(<span style="color: #D0372D;">ios_base</span>::failbit); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">add fail() to cin's state</span>
  }
</pre>
</div>

<p>
Custom <code>&lt;&lt;</code> and <code>&gt;&gt;</code> :
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">ostream</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">&lt;&lt;</span>(<span style="color: #6434A3;">ostream</span> &amp;<span style="color: #BA36A5;">os</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Entry</span> &amp;<span style="color: #BA36A5;">e</span>) {
    <span style="color: #0000FF;">return</span> os &lt;&lt; <span style="color: #008000;">"{\""</span> &lt;&lt; e.name &lt;&lt; <span style="color: #008000;">"\", "</span> &lt;&lt; e.number &lt;&lt; <span style="color: #008000;">"}"</span>;
  }

  <span style="color: #6434A3;">istream</span> &amp;<span style="color: #0000FF;">operator</span><span style="color: #006699;">&gt;&gt;</span>(<span style="color: #6434A3;">istream</span> &amp;<span style="color: #BA36A5;">is</span>, <span style="color: #6434A3;">Entry</span> &amp;<span style="color: #BA36A5;">e</span>) {
    <span style="color: #6434A3;">char</span> <span style="color: #BA36A5;">c</span>, <span style="color: #BA36A5;">c2</span>;
    <span style="color: #0000FF;">if</span> (is &gt;&gt; c &amp;&amp; c == <span style="color: #008000;">'{'</span> &amp;&amp; is &gt;&gt; c2 &amp;&amp; c2 == <span style="color: #008000;">'"'</span>) { <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">start with a {"</span>
      <span style="color: #6434A3;">string</span> <span style="color: #BA36A5;">name</span>;                                      <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">read a string name</span>
      <span style="color: #0000FF;">while</span> (is.get(c) &amp;&amp; c != <span style="color: #008000;">'"'</span>)                     <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">end with "</span>
        name += c;
      <span style="color: #0000FF;">if</span> (is &gt;&gt; c &amp;&amp; c == <span style="color: #008000;">','</span>) { <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">seperated by ,</span>
        <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">number</span> = 0;
        <span style="color: #0000FF;">if</span> (is &gt;&gt; number &gt;&gt; c &amp;&amp; c == <span style="color: #008000;">'}'</span>) { <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">read the number and a }</span>
          e = {name, number};
          <span style="color: #0000FF;">return</span> is;
        }
      }
    }
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">oh no</span>
    is.setstate(<span style="color: #D0372D;">ios_base</span>::failbit);
    <span style="color: #0000FF;">return</span> is;
  }
</pre>
</div>

<p>
Formatting:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #808080; font-weight: bold;">  #include</span><span style="color: #008000;">&lt;iostream&gt;</span>
<span style="color: #808080; font-weight: bold;">  #include</span><span style="color: #008000;">&lt;ios&gt;</span>
  <span style="color: #0000FF;">using</span> <span style="color: #0000FF;">namespace</span> <span style="color: #D0372D;">std</span>;

  <span style="color: #6434A3;">int</span> <span style="color: #006699;">main</span>(){
    cout &lt;&lt; 1234 &lt;&lt; <span style="color: #008000;">','</span>
         &lt;&lt; hex &lt;&lt; 1234 &lt;&lt; <span style="color: #008000;">','</span>
         &lt;&lt; oct &lt;&lt; 1234 &lt;&lt; <span style="color: #008000;">'\n'</span>;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">1234,4d2,2322</span>
    <span style="color: #0000FF;">constexpr</span> <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">d</span> = 123.456;
    cout &lt;&lt; d &lt;&lt; <span style="color: #008000;">"; "</span>
         &lt;&lt; scientific &lt;&lt; d &lt;&lt; <span style="color: #008000;">"; "</span>
         &lt;&lt; fixed &lt;&lt; d &lt;&lt; <span style="color: #008000;">"; "</span>
         &lt;&lt; defaultfloat &lt;&lt; d &lt;&lt; <span style="color: #008000;">'\n'</span>;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">123.456; 1.234560e+02; 123.456000; 123.456</span>
    cout.precision(2);
    cout &lt;&lt; fixed &lt;&lt; d &lt;&lt; <span style="color: #008000;">'\n'</span>;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">123.46</span>
  }
</pre>
</div>

<p>
<code>precision()</code> affects <code>defaultfloat</code>, <code>scientific</code>, <code>fixed</code>.
</p>

<p>
<code>#include &lt;iomanip&gt;</code> when using standard manipulators taking arguments.
</p>

<p>
Test files for reading and writing:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">ofstream</span> <span style="color: #BA36A5;">ofs</span>(<span style="color: #008000;">"target"</span>);
  <span style="color: #0000FF;">if</span> (<span style="color: #a277ff; font-weight: bold;">!</span>ofs) error(<span style="color: #008000;">"couldn't open 'target' for writing"</span>);
  <span style="color: #6434A3;">ifstream</span> <span style="color: #BA36A5;">ifs</span>(<span style="color: #008000;">"source"</span>);
  <span style="color: #0000FF;">if</span> (<span style="color: #a277ff; font-weight: bold;">!</span>ifs) error(<span style="color: #008000;">"couldn't open 'source' for reading"</span>);
</pre>
</div>

<p>
<code>&lt;sstream&gt;</code> : <code>istringstream</code>,  <code>ostringstream</code>, <code>stringstream</code>.
</p>

<p>
The result from an istringstream can be read using <code>str()</code>.
</p>

<p>
Use <code>stringstream</code> for in-memory formatting.
</p>
</div>
</div>

<div id="outline-container-org7175607" class="outline-2">
<h2 id="org7175607"><span class="section-number-2">9.</span> Containers</h2>
<div class="outline-text-2" id="text-9">
<p>
typical implementation of vector:
</p>
<ul class="org-ul">
<li>elem : a handle holding pointers to the first element</li>
<li>space : one-past-the-last element</li>
<li>last : one-past-the-last allocated space</li>
<li>alloc : allocator from which can acquire memory for elements</li>
</ul>

<p>
Initilize:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">vector</span>&lt;<span style="color: #6434A3;">int</span>&gt; <span style="color: #BA36A5;">v1</span> = {1, 2, 3, 4}; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">size is 4</span>
  <span style="color: #6434A3;">vector</span>&lt;<span style="color: #6434A3;">string</span>&gt; <span style="color: #BA36A5;">v2</span>;             <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">size is 0</span>
  <span style="color: #6434A3;">vector</span>&lt;<span style="color: #6434A3;">Shape</span>*&gt; <span style="color: #BA36A5;">v3</span>(23);         <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">size is 23; initial element value: nullptr</span>
  <span style="color: #6434A3;">vector</span>&lt;<span style="color: #6434A3;">double</span>&gt; <span style="color: #BA36A5;">v4</span>(32, 9.9);    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">size is 32; initial element value: 9.9</span>
</pre>
</div>

<p>
A vector can be copied in assignments and initializations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">vector</span>&lt;Entry&gt; <span style="color: #BA36A5;">book2</span> = phone_book;
</pre>
</div>

<p>
When you insert a new element, its value is copied into the container.
</p>

<p>
The <code>at()</code> operation throws an exception of type <code>out_of_range</code>
if its argument is out of the vector's range.
</p>

<p>
<code>list</code> : doubly-linked list.
</p>

<p>
<code>map</code> : a search tree (a red-black tree).
</p>

<p>
If a key isn’t found with <code>[]</code>, it is inserted into the <code>map</code> with a default value for its value.
</p>

<p>
<code>nordered_map</code>.
The standard-library provides a default hash function for strings
as well as for other built-in and standard-library types.
If necessary, you can provide your own.
</p>

<p>
A hash function is often provided as a function object:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">Record</span> {
    <span style="color: #6434A3;">string</span> <span style="color: #BA36A5;">name</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">product_code</span>;
    <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  };
  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">a hash function for Record</span>
  <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">Rhash</span> {
    <span style="color: #6434A3;">size_t</span> <span style="color: #0000FF;">operator</span><span style="color: #006699;">()</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">Record</span> &amp;<span style="color: #BA36A5;">r</span>) <span style="color: #0000FF;">const</span> {
      <span style="color: #0000FF;">return</span> hash&lt;<span style="color: #6434A3;">string</span>&gt;()(r.name) ^ hash&lt;<span style="color: #6434A3;">int</span>&gt;()(r.product_code);
    }
  };
  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">set of Recoreds using Rhash for lookup</span>
  <span style="color: #6434A3;">unordered_set</span>&lt;<span style="color: #6434A3;">Record</span>, <span style="color: #6434A3;">Rhash</span>&gt; <span style="color: #BA36A5;">my_set</span>;
</pre>
</div>

<p>
Creaing a new hash function by combining existing hash functions
using exclusive or (^) is simple and often very effective.
</p>

<ul class="org-ul">
<li>vector&lt;T&gt;, list&lt;T&gt;, forward_list&lt;T&gt;</li>
<li>map&lt;K,V&gt;, multimap&lt;K,V&gt;, unordered_map&lt;K,V&gt;, unordered_multimap&lt;K,V&gt;</li>
<li>set&lt;T&gt;, multiset&lt;T&gt;, unordered_set&lt;T&gt; unordered_multiset&lt;T&gt;</li>
<li>deque&lt;T&gt;, queue&lt;T&gt;, stack&lt;T&gt;, priority_queue&lt;T&gt;</li>
<li>fixed-size array <code>array&lt;T,N&gt;</code>, bitset&lt;N&gt;</li>
</ul>

<p>
Please note that a vector is usually more efficient than a list
for short sequences of small elements (even for insert() and erase()).
</p>

<p>
Use <code>forward_list</code> for sequences that are usually empty.
</p>

<p>
When it comes to performance, don’t trust your intuition: measure.
</p>

<p>
Pass a container by reference and return a container by value.
</p>
</div>
</div>

<div id="outline-container-org42e75f7" class="outline-2">
<h2 id="org42e75f7"><span class="section-number-2">10.</span> Algorithms</h2>
<div class="outline-text-2" id="text-10">
<div class="org-src-container">
<pre class="src src-c++">  sort(vec.begin(), vec.end());
  unique_copy(vec.begin(), vec.end(), lst.begin());
  unique_copy(vec.begin(), vec.end(), back_inserter(lst));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++">   <span style="color: #0000FF;">if</span> (find(s.begin(), s.end(), c) != s.end())
     <span style="color: #8D8D84; font-style: italic;">/* </span><span style="color: #8D8D84; font-style: italic;">...</span><span style="color: #8D8D84; font-style: italic;"> */</span>;
</pre>
</div>

<p>
each container knows its iterator types and makes them available
under the conventional names <code>iterator</code> and <code>const_iterator</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">template</span> &lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">C</span>, <span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">V</span>&gt;
  <span style="color: #6434A3;">vector</span>&lt;<span style="color: #0000FF;">typename</span> <span style="color: #D0372D;">C</span>::<span style="color: #6434A3;">iterator</span>&gt; <span style="color: #006699;">find_all</span>(<span style="color: #6434A3;">C</span> &amp;<span style="color: #BA36A5;">c</span>, <span style="color: #6434A3;">V</span> <span style="color: #BA36A5;">v</span>) {
</pre>
</div>

<p>
The typename is needed to inform the compiler that
C's iterator is supposed to be a type and not a value of some type.
</p>

<p>
With aliases:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #0000FF;">template</span>&lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">T</span>&gt;
<span style="color: #0000FF;">using</span> <span style="color: #6434A3;">Iterator</span> = <span style="color: #0000FF;">typename</span> <span style="color: #D0372D;">T</span>::iterator;

<span style="color: #0000FF;">template</span>&lt;<span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">C</span>, <span style="color: #0000FF;">typename</span> <span style="color: #6434A3;">V</span>&gt;
<span style="color: #6434A3;">vector</span>&lt;<span style="color: #6434A3;">Iterator</span>&lt;<span style="color: #6434A3;">C</span>&gt;&gt; <span style="color: #006699;">find_all</span>(<span style="color: #6434A3;">C</span>&amp; <span style="color: #BA36A5;">c</span>, <span style="color: #6434A3;">V</span> <span style="color: #BA36A5;">v</span>) {
</pre>
</div>

<p>
Stream iterator:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">int</span> <span style="color: #006699;">main</span>() {
    <span style="color: #6434A3;">ostream_iterator</span>&lt;<span style="color: #6434A3;">string</span>&gt; <span style="color: #BA36A5;">oo</span>{cout}; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">write strings to cout</span>
    *oo = <span style="color: #008000;">"Hello, "</span>;  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">meaning cout&lt;&lt;"Hello, "</span>
    ++oo;
    *oo = <span style="color: #008000;">"world!\n"</span>; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">meaning cout&lt;&lt;"world!\n"</span>
    <span style="color: #6434A3;">istream_iterator</span>&lt;<span style="color: #6434A3;">string</span>&gt; <span style="color: #BA36A5;">ii</span>{cin};
    <span style="color: #6434A3;">istream_iterator</span>&lt;<span style="color: #6434A3;">string</span>&gt; <span style="color: #BA36A5;">eos</span>{}; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">indicate the end of input</span>
  }
</pre>
</div>

<p>
Manipulate files:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">int</span> <span style="color: #006699;">unique_copy</span>(<span style="color: #6434A3;">string</span> <span style="color: #BA36A5;">from</span>, <span style="color: #6434A3;">string</span> <span style="color: #BA36A5;">to</span>) {
    <span style="color: #6434A3;">ifstream</span> <span style="color: #BA36A5;">is</span>{from};
    <span style="color: #6434A3;">ofstream</span> <span style="color: #BA36A5;">os</span>{to};
    <span style="color: #6434A3;">set</span>&lt;<span style="color: #6434A3;">string</span>&gt; <span style="color: #BA36A5;">b</span>{<span style="color: #6434A3;">istream_iterator</span>&lt;<span style="color: #6434A3;">string</span>&gt;{is}, <span style="color: #6434A3;">istream_iterator</span>&lt;<span style="color: #6434A3;">string</span>&gt;{}};
    copy(b.begin(), b.end(), <span style="color: #6434A3;">ostream_iterator</span>&lt;<span style="color: #6434A3;">string</span>&gt;{os, <span style="color: #008000;">"\n"</span>});
    <span style="color: #0000FF;">return</span> <span style="color: #a277ff; font-weight: bold;">!</span>is.eof() || <span style="color: #a277ff; font-weight: bold;">!</span>os;
  }
</pre>
</div>

<p>
Predictors:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">Greater_than</span> {
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">val</span>;
    <span style="color: #006699;">Greater_than</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">v</span>) : val{v} {}
    <span style="color: #6434A3;">bool</span> <span style="color: #0000FF;">operator</span><span style="color: #006699;">()</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">pair</span>&lt;<span style="color: #6434A3;">string</span>, <span style="color: #6434A3;">int</span>&gt; &amp;<span style="color: #BA36A5;">r</span>) { <span style="color: #0000FF;">return</span> r.second &gt; val; }
  };
  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">use as</span>
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">p</span> = find_if(m.begin(), m.end(), Greater_than{42});
  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">or lambda</span>
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">p</span> = find_if(m.begin(), m.end(), [](<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">pair</span>&lt;<span style="color: #6434A3;">string</span>,<span style="color: #6434A3;">int</span>&gt;&amp; <span style="color: #BA36A5;">r</span>) { <span style="color: #0000FF;">return</span> r.second&gt;42; });
</pre>
</div>

<p>
A predicate must not modify its argument.
</p>

<p>
Functions in <code>&lt;algorithm&gt;</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  p = find(b, e, x);
  p = find_if(b, e, f);
  n = count(b, e, x);
  n = count_if(b, e, f);
  replace(b, e, v, v2);
  replace_if(b, e, f, v2);
  p = copy(b, e, out); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">from [b:e) to [out:p)</span>
  p = copy_if(b, e, out, f);
  p = move(b, e, out);
  p = unique_copy(b, e, out);
  sort(b, e);
  sort(b, e, f);                   <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">Sort elements of [b:e) using f</span>
  (p1, p2) = equal_range(b, e, v); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">[p1:p2) is the subsequence with the value v</span>
  p = merge(b, e, b2, e2, out);
</pre>
</div>

<p>
Some algorithms, such as <code>replace()</code> and <code>sort()</code>, modify element values,
But <b>no algorithm add or subtract elements</b> of a container.
</p>

<p>
If you want to add elements, you need something,
such as an <code>back_inserter</code> that knows about the container.
</p>
</div>
</div>

<div id="outline-container-org79d1d41" class="outline-2">
<h2 id="org79d1d41"><span class="section-number-2">11.</span> Utilities</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-orga8483d7" class="outline-3">
<h3 id="orga8483d7"><span class="section-number-3">11.1.</span> Smart Pointers</h3>
<div class="outline-text-3" id="text-11-1">
<p>
In <code>&lt;memory&gt;</code>, the stan- dard library provides two 
smart pointers to help manage objects on the free store:
</p>
<ol class="org-ol">
<li><code>unique_ptr</code> to represent unique ownership</li>
<li><code>shared_ptr</code> to represent shared ownership</li>
</ol>

<p>
The <code>shared_ptr</code> is similar to <code>unique_ptr</code> except that
shared_ptrs are <b>copied rather than moved</b>.
</p>

<p>
The shared_ptrs for an object share ownership of an object and
that object is destroyed when the last of its shared_ptrs is destroyed.
</p>

<p>
the standard library (in <code>&lt;memory&gt;</code>) provides a function <code>make_shared()</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">shared_ptr</span>&lt;S&gt; <span style="color: #BA36A5;">p1</span>{<span style="color: #0000FF;">new</span> <span style="color: #6434A3;">S</span>{1, <span style="color: #008000;">"Ankh Morpork"</span>, 4.65}};
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">p2</span> = make_shared&lt;S&gt;(2, <span style="color: #008000;">"Oz"</span>, 7.62);
</pre>
</div>

<p>
Use <code>unique_ptr</code> to refer to objects of polymorphic type.
Use <code>shared_ptr</code> to refer to shared objects.
</p>
</div>
</div>

<div id="outline-container-org7a54d3b" class="outline-3">
<h3 id="org7a54d3b"><span class="section-number-3">11.2.</span> Specialized Containers</h3>
<div class="outline-text-3" id="text-11-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Almost Conainers</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Container</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T[N]</td>
<td class="org-left">Built-in array</td>
</tr>

<tr>
<td class="org-left">array&lt;T,N&gt;</td>
<td class="org-left">Like the built-in array, but <b>with most problems solved</b></td>
</tr>

<tr>
<td class="org-left">bitset&lt;N&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">vector&lt;bool&gt;</td>
<td class="org-left">A sequence of bits <b>compactly</b> stored in a specialization of vector</td>
</tr>

<tr>
<td class="org-left">pair&lt;T,U&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">tuple&lt;T&#x2026;&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">basic_string&lt;C&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">valarray&lt;T&gt;</td>
<td class="org-left">An array of numeric values of type T; provides numeric operations</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org7098981" class="outline-4">
<h4 id="org7098981"><span class="section-number-4">11.2.1.</span> array</h4>
<div class="outline-text-4" id="text-11-2-1">
<p>
An array, defined in <code>&lt;array&gt;</code>, is a fixed-size sequence of elements of a given type
where <b>the number of elements is specified at compile time</b>.
</p>

<p>
Thus, an array can be allocated with its elements on the stack,
in an object, or in static storage.
</p>

<p>
There is no overhead (time or space) involved in using an array
compared to using a built-in array.
</p>

<p>
An array knows its size, can be copied (using = or initialization),
and saves one from surprising nasty conversions to pointers.
</p>

<p>
An array does not "handle to elements."
</p>

<p>
The element count is not optional:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">array</span>&lt;<span style="color: #6434A3;">int</span>&gt; <span style="color: #BA36A5;">ax</span> = {1, 2, 3};
</pre>
</div>

<p>
an array can be explicitly passed to a C-style function that expects a pointer:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f</span>(<span style="color: #6434A3;">int</span>&#8727; p, <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">sz</span>); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">C-style interface</span>
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">g</span>() {
    <span style="color: #6434A3;">array</span>&lt;<span style="color: #6434A3;">int</span>, 10&gt; <span style="color: #BA36A5;">a</span>;
    f(a, a.size());                         <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">error: no conversion</span>
    f(&amp;a[0], a.size());                     <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">C-style use</span>
    f(a.data(), a.size());                  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">C-style use</span>
    <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">p</span> = find(a.begin(), a.end(), 777); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">C++/STL-style use</span>
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-org1efe77f" class="outline-4">
<h4 id="org1efe77f"><span class="section-number-4">11.2.2.</span> bitset</h4>
<div class="outline-text-4" id="text-11-2-2">
<p>
A <code>bitset</code> can be initialized with an integer or a string:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">bitset</span>&lt;9&gt; <span style="color: #BA36A5;">bs1</span>{<span style="color: #008000;">"110001111"</span>};
  <span style="color: #6434A3;">bitset</span>&lt;9&gt; <span style="color: #BA36A5;">bs2</span>{399};
  <span style="color: #6434A3;">bitset</span>&lt;9&gt; <span style="color: #BA36A5;">bs3</span> =  &#771;bs1;
  <span style="color: #6434A3;">bitset</span>&lt;9&gt; <span style="color: #BA36A5;">bs4</span> = bs1 &amp; bs3;
  <span style="color: #6434A3;">bitset</span>&lt;9&gt; <span style="color: #BA36A5;">bs5</span> = bs1 &lt;&lt; 2;
</pre>
</div>

<p>
<code>to_ullong()</code> and <code>to_string()</code> provide the inverse operations to the constructors.
</p>
</div>
</div>

<div id="outline-container-org94af234" class="outline-4">
<h4 id="org94af234"><span class="section-number-4">11.2.3.</span> pair and tuple</h4>
<div class="outline-text-4" id="text-11-2-3">
<p>
The make_pair() / make_tuple() function makes it easy to create
a pair / tuple without explicitly mentioning its type.
</p>

<p>
Elements of tuple can be accessed by <code>get&lt;0&gt;(t), get&lt;1&gt;(t), get&lt;2&gt;(t)</code>.
</p>
</div>
</div>

<div id="outline-container-orgc27d88b" class="outline-4">
<h4 id="orgc27d88b"><span class="section-number-4">11.2.4.</span> Time</h4>
<div class="outline-text-4" id="text-11-2-4">
<p>
The standard-library facilities for dealing with time
are found in the subnamespace <code>std::chrono</code> in <code>&lt;chrono&gt;</code>.
</p>

<p>
Timing something:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">using</span> <span style="color: #0000FF;">namespace</span> <span style="color: #D0372D;">std</span>::<span style="color: #D0372D;">chrono</span>;
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">t0</span> = <span style="color: #D0372D;">high_resolution_clock</span>::now();
  do_work();
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">t1</span> = <span style="color: #D0372D;">high_resolution_clock</span>::now();
  cout &lt;&lt; duration_cast&lt;milliseconds&gt;(t1&#8722;t0).count() &lt;&lt; <span style="color: #008000;">"msec\n"</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgae4f87b" class="outline-4">
<h4 id="orgae4f87b"><span class="section-number-4">11.2.5.</span> Function</h4>
<div class="outline-text-4" id="text-11-2-5">
<p>
A function adaptor takes a function as argument and returns a function object
that can be used to invoke the original function.
</p>

<p>
The standard library provides <code>bind()</code> and <code>mem_fn()</code> adaptors to do argument binding,
also called <i>Currying</i> or <i>partial evaluation</i>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #808080; font-weight: bold;">  #include</span><span style="color: #008000;">&lt;functional&gt;</span>
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f</span>(<span style="color: #6434A3;">int</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">string</span> &amp;);
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">g</span> = bind(f, 2, <span style="color: #D0372D;">placeholders</span>::_1); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">bind f()&#8217;s first argument to 2</span>
  f(2, <span style="color: #008000;">"hello"</span>);
  g(<span style="color: #008000;">"hello"</span>);
</pre>
</div>

<p>
Use <code>mem_fn()</code> to create function objects that can invoke a member function
when called using the traditional function call notation.
</p>
<div class="org-src-container">
<pre class="src src-c++">  p&#8722;&gt; draw();
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">draw</span> = mem_fn(&amp;<span style="color: #D0372D;">Shape</span>::draw);
  draw(p);

  for_each(v.begin(), v.end(), mem_fn(&amp;<span style="color: #D0372D;">Shape</span>::draw));
</pre>
</div>

<p>
Often, a lambda is an alternative to using <code>bind()</code> or <code>mem_fn()</code>.
</p>

<p>
A <code>function</code> is specified with a specific return type and a specific argument type:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">int</span> <span style="color: #006699;">f1</span>(<span style="color: #6434A3;">double</span>);
  <span style="color: #6434A3;">function</span>&lt;<span style="color: #6434A3;">int</span>(<span style="color: #6434A3;">double</span>)&gt; <span style="color: #BA36A5;">fct</span>{f1}; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">initialize to f1</span>

  <span style="color: #6434A3;">void</span> <span style="color: #006699;">user</span>() {
    fct = [](<span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">d</span>) { <span style="color: #0000FF;">return</span> round(d); }; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">assign lambda to fct</span>
    fct = f1;                                <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">assign function to fct</span>
  }
</pre>
</div>

<p>
Use function when you need to store something that can be called.
</p>

<p>
A type function is a function that is evaluated at compile-time
given a type as its argument or returning a type.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #808080; font-weight: bold;">  #include</span> <span style="color: #008000;">&lt;limits&gt;</span>
  <span style="color: #0000FF;">constexpr</span> <span style="color: #6434A3;">float</span> <span style="color: #BA36A5;">min</span> = <span style="color: #D0372D;">numeric_limits</span>&lt;<span style="color: #6434A3;">float</span>&gt;::min(); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">smallest positive float</span>
</pre>
</div>

<p>
Metaprogramming or (when templates are involved) template metaprogramming.
</p>

<p>
<code>iterator_trait</code>, tag dispatch, type predicates.
</p>

<p>
<code>&lt;type_traits&gt;</code> : is_arithmetic, is_class, is_pod, is_literal_type,
has_virtual_destructor, and is_base_of.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org63659fe" class="outline-2">
<h2 id="org63659fe"><span class="section-number-2">12.</span> Numerics</h2>
<div class="outline-text-2" id="text-12">
<p>
<code>&lt;math&gt;</code> for float, double, long double :
abs(x), ceil(x), floor(x), sqrt(x), cos(x), sin(x),
tan(x), acos(x), asin(x), sinh(x), cosh(x), tanh(x),
exp(x), log(x).
</p>

<p>
The versions for <code>complex</code> are found in <code>&lt;complex&gt;</code>.
</p>

<p>
Errors are reported by setting errno from <code>&lt;cerrno&gt;</code> to <code>EDOM</code>
for a domain error and to <code>ERANGE</code> for a range error:
</p>
<div class="org-src-container">
<pre class="src src-c++">  errno = 0; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">clear old error state</span>
  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  <span style="color: #0000FF;">if</span> (errno == EDOM) cerr &lt;&lt; <span style="color: #008000;">"domain error"</span>;
  <span style="color: #0000FF;">if</span> (errno == ERANGE) cerr &lt;&lt; <span style="color: #008000;">"range error"</span>;
</pre>
</div>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Numerical Algorithms in <code>&lt;numeric&gt;</code></caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">x=accumulate(b,e,i)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">x=accumulate(b,e,i,f)</td>
<td class="org-left">using f instead of +</td>
</tr>

<tr>
<td class="org-left">x=inner_product(b,e,b2,i)</td>
<td class="org-left">inner product of [b:e) and [b2:b2+(e−b)), i is initial value</td>
</tr>

<tr>
<td class="org-left">x=inner_product(b,e,b2,i,f,f2)</td>
<td class="org-left">using f and f2 instead of + and *</td>
</tr>

<tr>
<td class="org-left">p=partial_sum(b,e,out)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=partial_sum(b,e,out,f)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=adjacent_difference(b,e,out)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=adjacent_difference(b,e,out,f)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">iota(b,e,v)</td>
<td class="org-left">For each element in [b:e) assign ++v: v+1, v+2, &#x2026;</td>
</tr>
</tbody>
</table>

<p>
A random number generator consists of two parts:
</p>
<ol class="org-ol">
<li>an <b>engine</b> that produces a sequence of random or pseudo-random values.</li>
<li>a <b>distribution</b> that maps those values into a mathematical distribution in a range.</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">die</span> = bind(<span style="color: #6434A3;">uniform_int_distribution</span>&lt;&gt;{1, 6},
                  default_random_engine{});
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">x</span> = die();
</pre>
</div>

<p>
<code>valarray</code> in <code>&lt;valarray&gt;</code>  is less general and
more amenable to <b>optimization for numerical computation</b>.
</p>

<p>
Properties of numeric types are accessible through numeric_limits.
Use numeric_limits to check that the numeric types are adequate for their use.
</p>
</div>
</div>

<div id="outline-container-org72b2de8" class="outline-2">
<h2 id="org72b2de8"><span class="section-number-2">13.</span> Concurrency</h2>
<div class="outline-text-2" id="text-13">
<p>
threads, mutexes, lock() operations, packaged_tasks, and futures.
</p>

<p>
<b>task</b> s a computation that can potentially be executed concurrently with other computations.
A <b>thread</b> is the system-level representation of a task in a program.
</p>

<p>
A task is a function or a function object and launched as argument
by constructing a <code>std::thread</code> (found in <code>&lt;thread&gt;</code>).
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f</span>();  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">function</span>
  <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">F</span> { <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">function object</span>
    <span style="color: #6434A3;">void</span> <span style="color: #0000FF;">operator</span><span style="color: #006699;">()</span>();
  };
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">user</span>() {
    <span style="color: #6434A3;">thread</span> <span style="color: #BA36A5;">t1</span>{f};
    <span style="color: #6434A3;">thread</span> <span style="color: #BA36A5;">t2</span>{F()};
    t1.join(); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">wait for t1</span>
    t2.join(); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">wait for t2</span>
  }
</pre>
</div>

<p>
To <code>join</code> a thread means to wait for the thread to terminate.
</p>

<p>
Threads of a program <b>share a single address space</b>.
In this, threads differ from processes, which generally do not directly share data.
Since threads share an address space, they can communicate through shared objects.
</p>

<p>
The <code>ref()</code> is a type function from <code>&lt;functional&gt;</code> that unfortunately is needed
to tell the variadic template to treat some_vec as a reference,
rather than as an object.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f</span>(<span style="color: #6434A3;">vector</span>&lt;<span style="color: #6434A3;">double</span>&gt; &amp;<span style="color: #BA36A5;">v</span>);
  <span style="color: #6434A3;">thread</span> <span style="color: #BA36A5;">t1</span>{f, ref(some_vec)};
</pre>
</div>

<p>
pass the input data by const reference and to
pass the location of a place to deposit the result as a separate argument:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f</span>(<span style="color: #0000FF;">const</span> <span style="color: #6434A3;">vector</span>&lt;<span style="color: #6434A3;">double</span>&gt; &amp;<span style="color: #BA36A5;">v</span>, <span style="color: #6434A3;">double</span> *<span style="color: #BA36A5;">res</span>);
  <span style="color: #6434A3;">thread</span> <span style="color: #BA36A5;">t1</span>{f, cref(some_vec), &amp;res1};
</pre>
</div>
<p>
<code>cref</code> is for <code>const</code>.
</p>

<p>
A <code>mutex</code> in <code>&lt;mutex&gt;</code> is a mutual exclusion object.
A thread acquires a mutex using a <code>lock()</code> operation:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">mutex</span> <span style="color: #BA36A5;">m</span>;
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">sh</span>;
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f</span>() {
    <span style="color: #6434A3;">unique_lock</span>&lt;<span style="color: #6434A3;">mutex</span>&gt; <span style="color: #BA36A5;">lck</span>{m};
    sh += 7;
  } <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">release mutex implicitly</span>
</pre>
</div>
<p>
The <code>unique_lock</code> releases the mutex with a call <code>m.unlock()</code>.
</p>

<p>
Acquiring several locks simultaneously to avoid deadlock:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">unique_lock</span>&lt;mutex&gt; <span style="color: #BA36A5;">lck1</span> {m1,defer_lock};
  <span style="color: #6434A3;">unique_lock</span>&lt;mutex&gt; <span style="color: #BA36A5;">lck2</span> {m2,defer_lock};
  <span style="color: #6434A3;">unique_lock</span>&lt;mutex&gt; <span style="color: #BA36A5;">lck3</span> {m3,defer_lock};
  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
  lock(lck1,lck2,lck3);
</pre>
</div>

<p>
Sleep:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">using</span> <span style="color: #0000FF;">namespace</span> <span style="color: #D0372D;">std</span>::<span style="color: #D0372D;">chrono</span>;
  <span style="color: #D0372D;">this_thread</span>::sleep_for(milliseconds{20});
</pre>
</div>

<p>
The basic support for communicating using external events
is provided by condition_variables found in <code>&lt;condition_variable&gt;</code>.
A <code>condition_variable</code> is a mechanism allowing one thread to wait for another:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">queue</span>&lt;Message&gt; <span style="color: #BA36A5;">mqueue</span>;
  <span style="color: #6434A3;">condition_variable</span> <span style="color: #BA36A5;">mcond</span>;
  <span style="color: #6434A3;">mutex</span> <span style="color: #BA36A5;">mmutex</span>;

  <span style="color: #6434A3;">void</span> <span style="color: #006699;">consumer</span>() {
    <span style="color: #0000FF;">while</span> (<span style="color: #D0372D;">true</span>) {
      <span style="color: #6434A3;">unique_lock</span>&lt;<span style="color: #6434A3;">mutex</span>&gt; <span style="color: #BA36A5;">lck</span>{mmutex};
      <span style="color: #0000FF;">while</span> (mcond.wait(lck))
        <span style="color: #8D8D84; font-style: italic;">/* </span><span style="color: #8D8D84; font-style: italic;">do nothing</span><span style="color: #8D8D84; font-style: italic;"> */</span>;
      <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">m</span> = mqueue.front();
      mqueue.pop();
      lck.unlock();
      <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">process m...</span>
    }
  }
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">producer</span>() {
    <span style="color: #0000FF;">while</span> (<span style="color: #D0372D;">true</span>) {
      <span style="color: #6434A3;">Message</span> <span style="color: #BA36A5;">m</span>;
      <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">... fill the message ...</span>
      <span style="color: #6434A3;">unique_lock</span>&lt;<span style="color: #6434A3;">mutex</span>&gt; <span style="color: #BA36A5;">lck</span>{mmutex};
      mqueue.push(m);
      mcond.notify_one();
    }
  }
</pre>
</div>

<p>
<code>&lt;future&gt;</code>:
</p>
<ol class="org-ol">
<li>future and promise</li>
<li>packaged_task</li>
<li>async()</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">void</span> <span style="color: #006699;">f</span>(<span style="color: #6434A3;">promise</span>&lt;X&gt; &amp;<span style="color: #BA36A5;">px</span>) {
    <span style="color: #0000FF;">try</span> {
      <span style="color: #6434A3;">X</span> <span style="color: #BA36A5;">res</span>; <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">...</span>
      px.set_value(res);
    } <span style="color: #0000FF;">catch</span> (...) {
      px.set_exception(current_exception()); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">pass the exception</span>
    }
  }
  <span style="color: #6434A3;">void</span> <span style="color: #006699;">g</span>(<span style="color: #6434A3;">future</span>&lt;<span style="color: #6434A3;">X</span>&gt; &amp;<span style="color: #BA36A5;">fx</span>) { <span style="color: #6434A3;">X</span> <span style="color: #BA36A5;">v</span> = fx.get(); <span style="color: #8D8D84; font-style: italic;">/* </span><span style="color: #8D8D84; font-style: italic;">block</span><span style="color: #8D8D84; font-style: italic;"> */</span> }
</pre>
</div>

<p>
The packaged_task type is provided to simplify setting up tasks
connected with futures and promises to be run on threads:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #6434A3;">double</span> <span style="color: #006699;">accum</span>(<span style="color: #6434A3;">double</span>&#8727; beg, <span style="color: #6434A3;">double</span>&#8727; end, <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">init</span>) {
    <span style="color: #0000FF;">return</span> accumulate(beg, end, init);
  }
  <span style="color: #6434A3;">double</span> <span style="color: #006699;">sum</span>(<span style="color: #6434A3;">vector</span>&lt;<span style="color: #6434A3;">double</span>&gt;&amp; <span style="color: #BA36A5;">v</span>) {
    <span style="color: #0000FF;">using</span> <span style="color: #6434A3;">Task_type</span> = <span style="color: #6434A3;">double</span>(<span style="color: #6434A3;">double</span>&#8727;, <span style="color: #6434A3;">double</span>&#8727;, <span style="color: #6434A3;">double</span>); <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">accumulate</span>
    <span style="color: #6434A3;">packaged_task</span>&lt;Task_type&gt; <span style="color: #BA36A5;">pt0</span>{accum};
    <span style="color: #6434A3;">packaged_task</span>&lt;Task_type&gt; <span style="color: #BA36A5;">pt1</span>{accum};
    <span style="color: #6434A3;">future</span>&lt;<span style="color: #6434A3;">double</span>&gt; <span style="color: #BA36A5;">f0</span>{pt0.get_future()};
    <span style="color: #6434A3;">future</span>&lt;<span style="color: #6434A3;">double</span>&gt; <span style="color: #BA36A5;">f1</span>{pt1.get_future()};

    <span style="color: #6434A3;">double</span>&#8727; first = &amp;v[0];
    <span style="color: #6434A3;">thread</span> <span style="color: #BA36A5;">t1</span>{move(pt0), first, first + v.size() / 2, 0};
    <span style="color: #6434A3;">thread</span> <span style="color: #BA36A5;">t2</span>{move(pt1), first + v.size() / 2, first + v.size(), 0};
    <span style="color: #0000FF;">return</span> f0.get() + f1.get();
  }
</pre>
</div>

<p>
Using <code>async()</code>, you don’t have to think about threads and locks.
Instead, you think just in terms of tasks that potentially compute their results asynchronously:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">v0</span> = &amp;v[0]; <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">sz</span> = v.size();
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">f0</span> = async(accum, v0, v0 + sz / 4, 0.0);
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">f1</span> = async(accum, v0 + sz / 4, v0 + sz / 2, 0.0);
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">f2</span> = async(accum, v0 + sz / 2, v0 + sz&#8727;3 / 4, 0.0);
  <span style="color: #0000FF;">auto</span> <span style="color: #BA36A5;">f3</span> = async(accum, v0 + sz&#8727;3 / 4, v0 + sz, 0.0);
  <span style="color: #8D8D84; font-style: italic;">// </span><span style="color: #8D8D84; font-style: italic;">f0.get() + f1.get() + f2.get() + f3.get();</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: scturtle</p>
<p class="date">Created: 2023-06-14 Wed 18:53</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>