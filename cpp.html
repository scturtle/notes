<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-09 Sun 09:44 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Note of "A Tour of C++"</title>
<meta name="author" content="shen chao" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Note of &ldquo;A Tour of C++&rdquo;</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org49a4566">1. The Basics</a></li>
<li><a href="#orgea35d79">2. User-Defined Types</a></li>
<li><a href="#org70b4bd9">3. Modularity</a></li>
<li><a href="#org391a629">4. Classes</a>
<ul>
<li><a href="#org6e20e0c">4.1. Dynamic Casting</a></li>
<li><a href="#orgfb7b588">4.2. Copy and Move</a></li>
<li><a href="#org11ba44f">4.3. Essential Operations</a></li>
</ul>
</li>
<li><a href="#orga82e4e2">5. Templates</a></li>
<li><a href="#org734e1df">6. Library Overview</a></li>
<li><a href="#org91b6e85">7. Strings and Regular Expressions</a>
<ul>
<li><a href="#org2f7bb5c">7.1. Regular Expressions</a></li>
</ul>
</li>
<li><a href="#orgc8350ca">8. I/O Streams</a></li>
<li><a href="#org04f4191">9. Containers</a></li>
<li><a href="#org34e8a09">10. Algorithms</a></li>
<li><a href="#org412be84">11. Utilities</a>
<ul>
<li><a href="#org4195cee">11.1. Smart Pointers</a></li>
<li><a href="#orgef015fd">11.2. Specialized Containers</a></li>
</ul>
</li>
<li><a href="#org2b76d49">12. Numerics</a></li>
<li><a href="#orgb6db38e">13. Concurrency</a></li>
</ul>
</div>
</div>

<div id="outline-container-org49a4566" class="outline-2">
<h2 id="org49a4566"><span class="section-number-2">1.</span> The Basics</h2>
<div class="outline-text-2" id="text-1">
<p>
The minimal C++ program:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
If no value is returned, the system will receive a value
indicating successful completion.
</p>

<p>
A function declaration may contain argument names.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">double</span> <span class="org-function-name">square</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">return the square of the argument</span>
</pre>
</div>

<p>
If two functions are defined with the same name,
 but with different argument types,
 the compiler will choose the most appropriate function to invoke for each call.
</p>

<p>
Fundamental types: bool, char, int, double, unsigned.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-right">sizeof</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bool, char</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-right">8</td>
</tr>
</tbody>
</table>

<p>
<i>The usual arithmetic conversions: expressions
 are computed at the highest precision of its operands.</i>
</p>

<p>
Universal form based on curly-brace-delimited initializer lists:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-type">double</span> <span class="org-variable-name">d2</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">2.3</span><span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-type">complex</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">z3</span> = <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">the = is optional with { ... }</span>
</pre>
</div>

<p>
<code>auto</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">auto</span> <span class="org-variable-name">b</span> = <span class="org-constant">true</span>;
</pre>
</div>

<p>
<i>Range-for-statement</i>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">int</span> <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-1">[]</span> = <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">0</span>,<span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">2</span>,<span class="org-highlight-numbers-number">3</span>,<span class="org-highlight-numbers-number">4</span>,<span class="org-highlight-numbers-number">5</span>,<span class="org-highlight-numbers-number">6</span>,<span class="org-highlight-numbers-number">7</span>,<span class="org-highlight-numbers-number">8</span>,<span class="org-highlight-numbers-number">9</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span> : v<span class="org-rainbow-delimiters-depth-1">)</span> cout &lt;&lt; x &lt;&lt; <span class="org-string">'\n'</span>;
</pre>
</div>

<p>
Use <code>nullptr</code> rather than <code>0</code> or <code>NULL</code>.
</p>

<p>
Prefer the <code>{}</code>-initializer syntax for declarations with a named type,
prefer the <code>=</code> syntax for the initialization in declarations using <code>auto</code>.
</p>
</div>
</div>

<div id="outline-container-orgea35d79" class="outline-2">
<h2 id="orgea35d79"><span class="section-number-2">2.</span> User-Defined Types</h2>
<div class="outline-text-2" id="text-2">
<p>
A <code>struct</code> is simply a class with members public by default:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">V</span><span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-type">int</span> <span class="org-variable-name">val</span>; <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Vector</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Vector</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> : elem<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">new</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">[</span>s<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">}</span>, sz<span class="org-rainbow-delimiters-depth-2">{</span>s<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">member initializer list</span>
    <span class="org-type">double</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">[]</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> elem<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span>; <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">operation</span>
    <span class="org-type">int</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> sz; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">private</span>:
    <span class="org-type">double</span>* <span class="org-variable-name">elem</span>;
    <span class="org-type">int</span> <span class="org-variable-name">sz</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
A <code>union</code> is a <code>struct</code> in which all members are allocated at the same address
so that the <code>union</code> occupies only as much space as its largest member.
Naturally, a <code>union</code> can hold a value for only one member at a time.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">union</span> <span class="org-type">Value</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">char</span>* <span class="org-variable-name">s</span>;
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>


<p>
Enumeration:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-variable-name">red</span>, <span class="org-variable-name">blue</span>, <span class="org-variable-name">green</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">Color</span> <span class="org-variable-name">col</span> = <span class="org-constant">Color</span>::red;
</pre>
</div>

<p>
An enumeration is a user-defined type so we can define operators for it.
You can remove the <code>class</code> from <code>enum</code> class to get a plain <code>enum</code>
(<code>int</code> value starts with 0).
</p>
</div>
</div>

<div id="outline-container-org70b4bd9" class="outline-2">
<h2 id="org70b4bd9"><span class="section-number-2">3.</span> Modularity</h2>
<div class="outline-text-2" id="text-3">
<p>
Declarations / interfaces, <code>Vector.h</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Vector</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Vector</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">double</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">[]</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">int</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-keyword">private</span>:
    <span class="org-type">double</span>* <span class="org-variable-name">elem</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Avoid non-inline function definitions in headers.
</p>

<p>
Definitions / implementations, <code>Vector.cpp</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span> <span class="org-string">"Vector.h"</span>
  <span class="org-constant">Vector</span>::<span class="org-function-name">Vector</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-1">)</span> :elem<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-keyword">new</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">[</span>s<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">}</span>, sz<span class="org-rainbow-delimiters-depth-1">{</span>s<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-type">double</span>&amp; <span class="org-constant">Vector</span>::<span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-1">[]</span></span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> elem<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-type">int</span> <span class="org-constant">Vector</span>::<span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> sz; <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Namespaces:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">namespace</span> <span class="org-constant">My_code</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">class</span> <span class="org-type">complex</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">complex</span> <span class="org-function-name">sqrt</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">complex</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-type">int</span> <span class="org-constant">My_code</span>::<span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Don&rsquo;t put a using-directive in a header file.
</p>

<p>
Exceptions:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">stdexcept</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
  <span class="org-keyword">throw</span> out_of_range<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"Vector::operator[]"</span><span class="org-rainbow-delimiters-depth-1">}</span>;

  <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span> <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-1">(</span>out_of_range<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span> <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-function-name">...</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">any exception</span><span class="org-comment-delimiter"> */</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Logic errors: <code>logic_error</code>, <code>domain_error</code>, <code>invalid_argument</code>, <code>length_error</code>, <code>out_of_range</code>.
</p>

<p>
Runtime errors: <code>runtime_error</code>, <code>range_error</code>, <code>overflow_error</code>, <code>underflow_error</code>.
</p>

<p>
A function that should never throw an exception can be declared noexcept:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">user</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">sz</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>

<p>
If still throws, the standard-library function <code>terminate()</code>
 is called to immediately terminate the program.
</p>

<p>
If operator <code>new</code> can&rsquo;t find memory to allocate, it throws a <code>std::bad_alloc</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span> <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::bad_alloc<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::terminate<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">handle memory exhaustion</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
To rethrow the exception, we simply write <code>throw</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::length_error<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    cout &lt;&lt; <span class="org-string">"test failed: length error\n"</span>;
    <span class="org-keyword">throw</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">rethrow</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Compile time check:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">static_assert</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">4</span> &lt;= <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-string">"integers are too small"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org391a629" class="outline-2">
<h2 id="org391a629"><span class="section-number-2">4.</span> Classes</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>const</code> function:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">double</span> <span class="org-function-name">real</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> re; <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Operations change object itself should return reference:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">complex</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">+=</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">complex</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> re+=z.re, im+=z.im; <span class="org-keyword">return</span> *<span class="org-keyword">this</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Functions defined in a class are inlined by default.
It is possible to explicitly require inlining by
preceeding a function declaration with the keyword <code>inline</code>.
</p>

<p>
Clever ways of implementing operations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  complex <span class="org-keyword">operator</span>&#8722;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">complex</span> <span class="org-variable-name">a</span>, <span class="org-type">complex</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> a &#8722;= b; <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">unary minus</span>
  complex <span class="org-keyword">operator</span>&#8722;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">complex</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>&#8722;a.real<span class="org-rainbow-delimiters-depth-3">()</span>, &#8722;a.imag<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Destructor:
</p>
<div class="org-src-container">
<pre class="src src-c++">  ~<span class="org-function-name">Vector</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-2">[]</span> elem; <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Initializer-list constructor:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-constant">Vector</span>::<span class="org-function-name">Vector</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">initializer_list</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">lst</span><span class="org-rainbow-delimiters-depth-1">)</span>
      : elem<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-keyword">new</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">[</span>lst.size<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">}</span>, sz<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>lst.size<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    copy<span class="org-rainbow-delimiters-depth-2">(</span>lst.begin<span class="org-rainbow-delimiters-depth-3">()</span>, lst.end<span class="org-rainbow-delimiters-depth-3">()</span>, elem<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<code>push_back</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Vector</span> <span class="org-function-name">read</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">istream</span> &amp;<span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Vector</span> <span class="org-variable-name">v</span>;
    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">d</span>; is &gt;&gt; d;<span class="org-rainbow-delimiters-depth-2">)</span>
      v.push_back<span class="org-rainbow-delimiters-depth-2">(</span>d<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> v;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Abstract type:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Container</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">pure virtual function</span>
    <span class="org-keyword">virtual</span> <span class="org-type">double</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">[]</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-highlight-numbers-number">0</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">const member function</span>
    <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = <span class="org-highlight-numbers-number">0</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">destructor</span>
    <span class="org-keyword">virtual</span>  ~<span class="org-function-name">Container</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{}</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
The word <code>virtual</code> means &ldquo;may be redefined later in a class derived from this one.&rdquo;
</p>

<p>
The curious <code>=0</code> syntax says the function is pure virtual;
that is, some class derived from <code>Container</code> <b>must</b> define the function.
</p>

<p>
A class with a pure virtual function is called an abstract class
and it&rsquo;s not possible to define an object of it.
</p>

<p>
As is common for abstract class, it does <b>not</b> have a constructor.
On the other hand, it <b>does</b> have a destructor and that destructor is <code>virtual</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Vector_container</span> : <span class="org-keyword">public</span> <span class="org-type">Container</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Vector</span> <span class="org-variable-name">v</span>;

  <span class="org-keyword">public</span>:
    <span class="org-function-name">Vector_container</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> : v<span class="org-rainbow-delimiters-depth-2">(</span>s<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>
    ~<span class="org-function-name">Vector_container</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{}</span>
    <span class="org-type">double</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">[]</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> v<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">int</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> v.size<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Note that the member destructor (<code>~Vector()</code>) is implicitly invoked
by its class&rsquo;s destructor (<code>~Vector_container()</code>).
</p>

<p>
Virtual function table (<code>vtbl</code>).
</p>

<p>
A function in a derived class overrides a virtual function
in a base class if that function has exactly the same name and type.
</p>

<p>
A function with a slightly different name or a slightly different type
may be intended to override or it may be intended to be a separate function.
</p>

<p>
Explicitly state that a function is meant to override:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">move</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Point</span> <span class="org-variable-name">to</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">override</span>;
</pre>
</div>
</div>

<div id="outline-container-org6e20e0c" class="outline-3">
<h3 id="org6e20e0c"><span class="section-number-3">4.1.</span> Dynamic Casting</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Dynamic casting:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Smiley</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Smiley</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>ps<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<p>
If the object pointed to by the argument of <code>dynamic_cast</code>
is not of the expected type or a class derived from the expected type,
<code>dynamic_cast</code> returns <code>nullptr</code>.
</p>

<p>
When a different type is unacceptable, we can simply <code>dynamic_cast</code> to a reference type.
If the object is not of the expected type, <code>bad_cast</code> is thrown:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Smiley</span> &amp;<span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Smiley</span> &amp;<span class="org-rainbow-delimiters-depth-2">&gt;(</span>*ps<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Better resource handling: return <code>unique_ptr</code> rather than
a naked pointer and store <code>unique_ptrs</code> in the container:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>Shape<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">v</span>;
  v.push_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>Shape<span class="org-rainbow-delimiters-depth-2">&gt;{</span><span class="org-keyword">new</span> <span class="org-type">Circle</span><span class="org-rainbow-delimiters-depth-3">{</span>p, r<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Now the object is owned by the <code>unique_ptr</code> which will delete the object
when it is no longer needed, that is, when its <code>unique_ptr</code> goes out of scope.
</p>
</div>
</div>

<div id="outline-container-orgfb7b588" class="outline-3">
<h3 id="orgfb7b588"><span class="section-number-3">4.2.</span> Copy and Move</h3>
<div class="outline-text-3" id="text-4-2">
<p>
By default, objects can be copied.
The default meaning of copy is memberwise copy: copy each member.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">complex</span> <span class="org-variable-name">z2</span><span class="org-rainbow-delimiters-depth-1">{</span>z1<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">copy initialization</span>
  <span class="org-type">complex</span> <span class="org-variable-name">z3</span>;
  z3 = z2;        <span class="org-comment-delimiter">// </span><span class="org-comment">copy assignment</span>
</pre>
</div>

<p>
Copy constructor and copy assignment:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector</span> &amp;<span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">)</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">copy constructor</span>
  <span class="org-type">Vector</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector</span> &amp;<span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">copy assignment</span>

  <span class="org-constant">Vector</span>::<span class="org-function-name">Vector</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector</span> &amp;<span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">)</span> : elem<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-keyword">new</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">[</span>a.sz<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">}</span>, sz<span class="org-rainbow-delimiters-depth-1">{</span>a.sz<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = <span class="org-highlight-numbers-number">0</span>; i != sz; ++i<span class="org-rainbow-delimiters-depth-2">)</span>
      elem<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> = a.elem<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>

  <span class="org-type">Vector</span> &amp;<span class="org-constant">Vector</span>::<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector</span> &amp;<span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">double</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">[</span>a.sz<span class="org-rainbow-delimiters-depth-2">]</span>;
    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = <span class="org-highlight-numbers-number">0</span>; i != a.sz; ++i<span class="org-rainbow-delimiters-depth-2">)</span>
      p<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> = a.elem<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span>;
    <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-2">[]</span> elem; <span class="org-comment-delimiter">// </span><span class="org-comment">delete old elements</span>
    elem = p;
    sz = a.sz;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
To avoid copying in returning value:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Vector</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Vector</span> <span class="org-variable-name">res</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-keyword">return</span> res;
  <span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Move constructor and move assignment should be implemented:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector</span> &amp;&amp;<span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">)</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">move constructor</span>
  <span class="org-type">Vector</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector</span> &amp;&amp;<span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">move assignment</span>

  <span class="org-constant">Vector</span>::<span class="org-function-name">Vector</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector</span> &amp;&amp;<span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">)</span>
      : elem<span class="org-rainbow-delimiters-depth-1">{</span>a.elem<span class="org-rainbow-delimiters-depth-1">}</span>, sz<span class="org-rainbow-delimiters-depth-1">{</span>a.sz<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-comment-delimiter">// </span><span class="org-comment">"grab the elements" from a</span>
    a.elem = <span class="org-constant">nullptr</span>; a.sz = <span class="org-highlight-numbers-number">0</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">now a has no elements</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The <code>&amp;&amp;</code> means <i>rvalue</i> reference and is a reference to which we can bind an rvalue.
The word &ldquo;rvalue&rdquo; is intended to complement &ldquo;lvalue,&rdquo; which roughly means
&ldquo;something that can appear on the left-hand side of an assignment.&rdquo;
So an <b>rvalue</b> is – to a first approximation – <b>a value that you can&rsquo;t assign to</b>,
such as an integer returned by a function call.
Thus, an rvalue reference is a reference to something that nobody else can assign to,
so that we can safely &ldquo;steal&rdquo; its value.
</p>

<p>
A move operation is applied when an rvalue reference is used
as an initializer or as the right-hand side of an assignment.
</p>

<p>
Manually move with <code>std::move</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Vector</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    z = x;            <span class="org-comment-delimiter">// </span><span class="org-comment">we get a copy</span>
    y = <span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">we get a move</span>
    <span class="org-keyword">return</span> z;         <span class="org-comment-delimiter">// </span><span class="org-comment">we get a move</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org11ba44f" class="outline-3">
<h3 id="org11ba44f"><span class="section-number-3">4.3.</span> Essential Operations</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">X</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>:
    X<span class="org-rainbow-delimiters-depth-2">(</span>Sometype<span class="org-rainbow-delimiters-depth-2">)</span>;             <span class="org-comment-delimiter">// </span><span class="org-comment">ordinary constructor: create an object</span>
    <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span>;                     <span class="org-comment-delimiter">// </span><span class="org-comment">default constructor</span>
    <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">X</span> &amp;<span class="org-rainbow-delimiters-depth-2">)</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">copy constructor</span>
    <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">X</span> &amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;                 <span class="org-comment-delimiter">// </span><span class="org-comment">move constructor</span>
    <span class="org-type">X</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">X</span> &amp;<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">copy assignment: clean up target and copy</span>
    <span class="org-type">X</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">X</span> &amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">move assignment: clean up target and move</span>
    ~<span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span>;                    <span class="org-comment-delimiter">// </span><span class="org-comment">destructor: clean up</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Except for the ordinary constructor, these can be generated by compiler:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Y</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>:
    Y<span class="org-rainbow-delimiters-depth-2">(</span>Sometype<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-function-name">Y</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Y</span> &amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">default</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">I really want the default copy constructor</span>
    <span class="org-function-name">Y</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Y</span> &amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">default</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">I really want the default copy constructor</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
If you are explicit about some defaults,
other default definitions will not be generated.
</p>

<p>
Eliminate the default definitions of those two operations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Shape</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">no copy operations</span>
    <span class="org-function-name">Shape</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Shape</span> &amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    <span class="org-type">Shape</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Shape</span> &amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">no move operations</span>
    <span class="org-function-name">Shape</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Shape</span> &amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    <span class="org-type">Shape</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Shape</span> &amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    ~<span class="org-function-name">Shape</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
A constructor taking a single argument defines a conversion from its argument type,
but if only <code>explicit</code> conversion is allowed:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Vector</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>:
    <span class="org-keyword">explicit</span> <span class="org-function-name">Vector</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no implicit conversion from int to Vector</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<i>C++ also offers a garbage collection interface
 so that you can plug in a garbage collector.</i>
</p>

<p>
In the C++ standard library, RAII (Resource Acquisition Is Initialization) is pervasive:
 for example, memory (string, vector, map, <code>unordered_map</code>, etc.),
 files (ifstream, ofstream, etc.), threads (thread), locks (<code>lock_guard</code>, <code>unique_lock</code>, etc.),
 and general objects (through <code>unique_ptr</code> and <code>shared_ptr</code>).
</p>
</div>
</div>
</div>

<div id="outline-container-orga82e4e2" class="outline-2">
<h2 id="orga82e4e2"><span class="section-number-2">5.</span> Templates</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-keyword">class</span> <span class="org-type">Vector</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">private</span>:
    <span class="org-type">T</span>* <span class="org-variable-name">elem</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-constant">Vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-function-name">Vector</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
</pre>
</div>

<p>
Using <code>class</code> to introduce a type parameter is equivalent to using <code>typename</code>,
and in older code we often see <code>template&lt;class T&gt;</code> as the prefix.
</p>

<p>
The <code>&gt;&gt;</code> in <code>Vector&lt;list&lt;int&gt;&gt;</code> terminates the nested template arguments;
it is not a misplaced input operator.
It is not (as in C++98) necessary to place a space between the two &gt;s.
</p>

<p>
Provide <code>begin()</code> and <code>end()</code> to support <code>range-for</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-type">T</span> *<span class="org-function-name">begin</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">pointer to first element or nullptr</span>
    <span class="org-keyword">return</span> x.size<span class="org-rainbow-delimiters-depth-2">()</span> ? &amp;x<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">]</span> : <span class="org-constant">nullptr</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-type">T</span> *<span class="org-function-name">end</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">pointer to one-past-last element</span>
    <span class="org-keyword">return</span> begin<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span> + x.size<span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-type">void</span> <span class="org-function-name">f2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">vs</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> &amp;<span class="org-variable-name">s</span> : vs<span class="org-rainbow-delimiters-depth-2">)</span>
      cout &lt;&lt; s &lt;&lt; <span class="org-string">'\n'</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Templates are a compile-time mechanism,
so their use incurs no run-time overhead compared to hand-crafted code.
</p>

<p>
A template can take value arguments:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-type">int</span> <span class="org-variable-name">N</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-keyword">struct</span> <span class="org-type">Buffer</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">using</span> <span class="org-type">value_type</span> = T;
    <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> N; <span class="org-rainbow-delimiters-depth-2">}</span>
    T<span class="org-rainbow-delimiters-depth-2">[</span>N<span class="org-rainbow-delimiters-depth-2">]</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
The alias <code>value_type</code> and the <code>constexpr</code> function are provided
to allow users (read-only) access to the template arguments.
</p>

<p>
Can be used to create arbitrarily sized buffers on stack:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Buffer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span>,<span class="org-highlight-numbers-number">1024</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">glob</span>;
</pre>
</div>

<p>
Function object: objects that can be called like functions:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-keyword">class</span> <span class="org-type">Less_than</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">const</span> <span class="org-type">T</span> <span class="org-variable-name">val</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">value to compare against</span>
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Less_than</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">T</span> &amp;<span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> : val<span class="org-rainbow-delimiters-depth-2">(</span>v<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>
    <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">T</span> &amp;<span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> x &lt; val; <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">call operator</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;

  count<span class="org-rainbow-delimiters-depth-1">(</span>vec, <span class="org-type">Less_than</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;{</span>x<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Lambda expression:
</p>
<div class="org-src-container">
<pre class="src src-c++">  count<span class="org-rainbow-delimiters-depth-1">(</span>vec, <span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> a &lt; x; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Capture nothing is <code>[ ]</code> , capture all local names used by reference is <code>[&amp;]</code> ,
 and capture all local names used by value is <code>[=]</code> .
</p>

<p>
Had we wanted to capture only x, we could have said so: <code>[&amp;x]</code> .
Had we wanted to give the generated object a copy of x,
we could have said so: <code>[=x]</code> .
</p>

<p>
Variadic templates:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">do nothing</span>
  <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span><span class="org-function-name">...</span> <span class="org-type">Tail</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-type">void</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">head</span>, <span class="org-type">Tail</span><span class="org-function-name">...</span> <span class="org-variable-name">tail</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    g<span class="org-rainbow-delimiters-depth-2">(</span>head<span class="org-rainbow-delimiters-depth-2">)</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">do something to head</span>
    f<span class="org-rainbow-delimiters-depth-2">(</span>tail<span class="org-function-name">...</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">try again with tail</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Another example in chapter 11:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span><span class="org-function-name">...</span> <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-function-name">make_unique</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Args</span> &amp;&amp;<span class="org-function-name">...</span> <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;{</span><span class="org-keyword">new</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">std</span>::forward<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>args<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-function-name">...</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Aliases:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-comment-delimiter">// </span><span class="org-comment">in &lt;cstddef&gt;</span>
  <span class="org-keyword">using</span> <span class="org-type">size_t</span> = <span class="org-type">unsigned</span> <span class="org-type">int</span>;
</pre>
</div>

<p>
It is very common for a parameterized type to provide
an alias for types related to their template arguments.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-keyword">class</span> <span class="org-type">Vector</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>:
    <span class="org-keyword">using</span> <span class="org-type">value_type</span> = T;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
In fact, every standard-library container provides
<code>value_type</code> as the name of its value type.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-keyword">using</span> <span class="org-type">Element_type</span> = <span class="org-keyword">typename</span> <span class="org-constant">C</span>::value_type;

  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-type">void</span> <span class="org-function-name">algo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Container</span> &amp;<span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element_type</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">vec</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
A function template argument needs to be explicitly mentioned
only if it cannot be deduced or if there is no default:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Target</span> = string, <span class="org-keyword">typename</span> <span class="org-type">Source</span> = string<span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-type">Target</span> <span class="org-function-name">to</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Source</span> <span class="org-variable-name">arg</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">x1</span> = to<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">string</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-highlight-numbers-number">1.2</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">x2</span> = to<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-highlight-numbers-number">1.2</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Source is deduced to double</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">x3</span> = to<span class="org-rainbow-delimiters-depth-2">&lt;&gt;(</span><span class="org-highlight-numbers-number">1.2</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">x4</span> = to<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1.2</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org734e1df" class="outline-2">
<h2 id="org734e1df"><span class="section-number-2">6.</span> Library Overview</h2>
<div class="outline-text-2" id="text-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Selected Standard Library Headers</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">header</th>
<th scope="col" class="org-left">declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&lt;string&gt;</td>
<td class="org-left">string, basic_string</td>
</tr>

<tr>
<td class="org-left">&lt;regex&gt;</td>
<td class="org-left">regex, smatch</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;fstream&gt;</td>
<td class="org-left">fstream, ifstream, ofstream</td>
</tr>

<tr>
<td class="org-left">&lt;iostream&gt;</td>
<td class="org-left">istream, ostream, cin, cout</td>
</tr>

<tr>
<td class="org-left">&lt;sstream&gt;</td>
<td class="org-left">istrstream, ostrstream</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;array&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">&lt;vector&gt;</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">&lt;set&gt;</td>
<td class="org-left">set, multiset</td>
</tr>

<tr>
<td class="org-left">&lt;map&gt;</td>
<td class="org-left">map, multimap</td>
</tr>

<tr>
<td class="org-left">&lt;unordered_map&gt;</td>
<td class="org-left">unordered_map, unordered_multimap</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;algorithm&gt;</td>
<td class="org-left">copy(), find(), sort()</td>
</tr>

<tr>
<td class="org-left">&lt;random&gt;</td>
<td class="org-left">default_random_engine, normal_distribution</td>
</tr>

<tr>
<td class="org-left">&lt;memory&gt;</td>
<td class="org-left">unique_ptr, shared_ptr, allocator</td>
</tr>

<tr>
<td class="org-left">&lt;utility&gt;</td>
<td class="org-left">move(), swap(), pair</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;cmath&gt;</td>
<td class="org-left">sqrt(), pow()</td>
</tr>

<tr>
<td class="org-left">&lt;complex&gt;</td>
<td class="org-left">complex, sqrt(), pow()</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;future&gt;</td>
<td class="org-left">future, promise</td>
</tr>

<tr>
<td class="org-left">&lt;thread&gt;</td>
<td class="org-left">thread</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;forward_list&gt;</td>
<td class="org-left">forward_list</td>
</tr>

<tr>
<td class="org-left">&lt;stdexcept&gt;</td>
<td class="org-left">length_error, out_of_range, runtime_error</td>
</tr>

<tr>
<td class="org-left">&lt;chrono&gt;</td>
<td class="org-left">duration, time_point</td>
</tr>

<tr>
<td class="org-left">&lt;ios&gt;</td>
<td class="org-left">hex,dec,scientific,fixed,defaultfloat</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org91b6e85" class="outline-2">
<h2 id="org91b6e85"><span class="section-number-2">7.</span> Strings and Regular Expressions</h2>
<div class="outline-text-2" id="text-7">
<p>
A string is mutable: <code>=</code>, <code>+=</code>, <code>[]</code>.
</p>

<p>
<code>.size()</code>, <code>.insert()</code>, <code>.erase()</code>, <code>.find()</code> (<code>string::npos</code>),
<code>.substr()</code>, <code>.replace()</code>, <code>.c_str()</code> (read-only).
</p>

<p>
<b>short-string optimization</b>: short string values are kept in the string object itself
and only longer strings are placed on free store.
</p>

<p>
<code>string</code> is really an alias for a general template <code>basic_string</code>
with the character type <code>char</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">using</span> <span class="org-type">string</span> = <span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
</pre>
</div>

<p>
<code>wstring</code>, <code>u16string</code>, <code>u32string</code>.
</p>
</div>

<div id="outline-container-org2f7bb5c" class="outline-3">
<h3 id="org2f7bb5c"><span class="section-number-3">7.1.</span> Regular Expressions</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Pattern:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">regex</span> <span class="org-function-name">pat</span> <span class="org-rainbow-delimiters-depth-1">(</span>R"<span class="org-string">(\w{2}\s&#8727;\d{5}(&#8722;\d{4})?)</span>"<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<code>regex_match()</code>, <code>regex_search()</code>, <code>regex_replace()</code>, <code>regex_iterator</code>, <code>regex_token_iterator</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">int</span> <span class="org-variable-name">lineno</span> = <span class="org-highlight-numbers-number">0</span>;
  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">string</span> <span class="org-variable-name">line</span>; getline<span class="org-rainbow-delimiters-depth-2">(</span>cin, line<span class="org-rainbow-delimiters-depth-2">)</span>;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    ++lineno;
    <span class="org-type">smatch</span> <span class="org-variable-name">matches</span>;
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>regex_search<span class="org-rainbow-delimiters-depth-3">(</span>line, matches, pat<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
      cout &lt;&lt; lineno &lt;&lt; <span class="org-string">": "</span> &lt;&lt; matches<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">'\n'</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
An smatch is a vector of sub-matches of type string.
The first element, here <code>matches[0]</code>, is the complete match.
</p>

<p>
Sub-match:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span> &lt; matches.size<span class="org-rainbow-delimiters-depth-2">()</span> &amp;&amp; matches<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-2">]</span>.matched<span class="org-rainbow-delimiters-depth-1">)</span>
    cout &lt;&lt; <span class="org-string">"\t: "</span> &lt;&lt; matches<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">]</span> &lt;&lt; <span class="org-string">'\n'</span>;
</pre>
</div>

<p>
Regular expressions are compiled into state machines for efficient execution.
</p>

<p>
Character classes and abbreviations (skipped here).
</p>

<p>
Iterator:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">string</span> <span class="org-variable-name">input</span> = <span class="org-string">"aa as; asd ++e&#710;asdf asdfg"</span>;
  <span class="org-type">regex</span> <span class="org-variable-name">pat</span><span class="org-rainbow-delimiters-depth-1">{</span>R"<span class="org-string">(\s+(\w+))</span>"<span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">sregex_iterator</span> <span class="org-function-name">p</span><span class="org-rainbow-delimiters-depth-2">(</span>input.begin<span class="org-rainbow-delimiters-depth-3">()</span>, input.end<span class="org-rainbow-delimiters-depth-3">()</span>, pat<span class="org-rainbow-delimiters-depth-2">)</span>;
       p != sregex_iterator<span class="org-rainbow-delimiters-depth-2">{}</span>; ++p<span class="org-rainbow-delimiters-depth-1">)</span>
    cout &lt;&lt; <span class="org-rainbow-delimiters-depth-1">(</span>*p<span class="org-rainbow-delimiters-depth-1">)[</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">]</span> &lt;&lt; <span class="org-string">'\n'</span>;
</pre>
</div>

<p>
Return strings by value (rely on move semantics).
</p>

<p>
Use a string_stream or a generic value extraction function (such as <code>to&lt;X&gt;</code>)
for numeric conversion of strings.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc8350ca" class="outline-2">
<h2 id="orgc8350ca"><span class="section-number-2">8.</span> I/O Streams</h2>
<div class="outline-text-2" id="text-8">
<p>
By default, <code>&gt;&gt;</code> skips initial whitespace.
</p>

<p>
By default, a whitespace character, such as a space or a newline, terminates the read.
You can read a whole line (including the terminating newline character) using the <code>getline()</code> function.
</p>
<div class="org-src-container">
<pre class="src src-c++">getline<span class="org-rainbow-delimiters-depth-1">(</span>cin,str<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
I/O state:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-1">(</span>cin &gt;&gt; i<span class="org-rainbow-delimiters-depth-1">)</span>
    res.push_back<span class="org-rainbow-delimiters-depth-1">(</span>i<span class="org-rainbow-delimiters-depth-1">)</span>;

  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span>cin.eof<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span>cin.fail<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-comment-delimiter">// </span><span class="org-comment">a potentially recoverable error</span>
    cin.clear<span class="org-rainbow-delimiters-depth-2">()</span>;           <span class="org-comment-delimiter">// </span><span class="org-comment">reset the state to good()</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">if fail again</span>
    cin.setstate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">ios_base</span>::failbit<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">add fail() to cin's state</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Custom <code>&lt;&lt;</code> and <code>&gt;&gt;</code> :
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">ostream</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">&lt;&lt;</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">ostream</span> &amp;<span class="org-variable-name">os</span>, <span class="org-keyword">const</span> <span class="org-type">Entry</span> &amp;<span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> os &lt;&lt; <span class="org-string">"{\""</span> &lt;&lt; e.name &lt;&lt; <span class="org-string">"\", "</span> &lt;&lt; e.number &lt;&lt; <span class="org-string">"}"</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>

  <span class="org-type">istream</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">&gt;&gt;</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">istream</span> &amp;<span class="org-variable-name">is</span>, <span class="org-type">Entry</span> &amp;<span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">char</span> <span class="org-variable-name">c</span>, <span class="org-variable-name">c2</span>;
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>is &gt;&gt; c &amp;&amp; c == <span class="org-string">'{'</span> &amp;&amp; is &gt;&gt; c2 &amp;&amp; c2 == <span class="org-string">'"'</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-comment-delimiter">// </span><span class="org-comment">start with a {"</span>
      <span class="org-type">string</span> <span class="org-variable-name">name</span>;                                      <span class="org-comment-delimiter">// </span><span class="org-comment">read a string name</span>
      <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span>is.get<span class="org-rainbow-delimiters-depth-4">(</span>c<span class="org-rainbow-delimiters-depth-4">)</span> &amp;&amp; c != <span class="org-string">'"'</span><span class="org-rainbow-delimiters-depth-3">)</span>                     <span class="org-comment-delimiter">// </span><span class="org-comment">end with "</span>
        name += c;
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>is &gt;&gt; c &amp;&amp; c == <span class="org-string">','</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-comment-delimiter">// </span><span class="org-comment">seperated by ,</span>
        <span class="org-type">int</span> <span class="org-variable-name">number</span> = <span class="org-highlight-numbers-number">0</span>;
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>is &gt;&gt; number &gt;&gt; c &amp;&amp; c == <span class="org-string">'}'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-comment-delimiter">// </span><span class="org-comment">read the number and a }</span>
          e = <span class="org-rainbow-delimiters-depth-1">{</span>name, number<span class="org-rainbow-delimiters-depth-1">}</span>;
          <span class="org-keyword">return</span> is;
        <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">oh no</span>
    is.setstate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">ios_base</span>::failbit<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> is;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Formatting:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">  #include</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">ios</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

  <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    cout &lt;&lt; <span class="org-highlight-numbers-number">1234</span> &lt;&lt; <span class="org-string">','</span>
         &lt;&lt; hex &lt;&lt; <span class="org-highlight-numbers-number">1234</span> &lt;&lt; <span class="org-string">','</span>
         &lt;&lt; oct &lt;&lt; <span class="org-highlight-numbers-number">1234</span> &lt;&lt; <span class="org-string">'\n'</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">1234,4d2,2322</span>
    <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">d</span> = <span class="org-highlight-numbers-number">123.456</span>;
    cout &lt;&lt; d &lt;&lt; <span class="org-string">"; "</span>
         &lt;&lt; scientific &lt;&lt; d &lt;&lt; <span class="org-string">"; "</span>
         &lt;&lt; fixed &lt;&lt; d &lt;&lt; <span class="org-string">"; "</span>
         &lt;&lt; defaultfloat &lt;&lt; d &lt;&lt; <span class="org-string">'\n'</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">123.456; 1.234560e+02; 123.456000; 123.456</span>
    cout.precision<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    cout &lt;&lt; fixed &lt;&lt; d &lt;&lt; <span class="org-string">'\n'</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">123.46</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<code>precision()</code> affects <code>defaultfloat</code>, <code>scientific</code>, <code>fixed</code>.
</p>

<p>
<code>#include &lt;iomanip&gt;</code> when using standard manipulators taking arguments.
</p>

<p>
Test files for reading and writing:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">ofstream</span> <span class="org-variable-name">ofs</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"target"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>ofs<span class="org-rainbow-delimiters-depth-1">)</span> error<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"couldn't open 'target' for writing"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-type">ifstream</span> <span class="org-variable-name">ifs</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"source"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>ifs<span class="org-rainbow-delimiters-depth-1">)</span> error<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"couldn't open 'source' for reading"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<code>&lt;sstream&gt;</code> : <code>istringstream</code>,  <code>ostringstream</code>, <code>stringstream</code>.
</p>

<p>
The result from an istringstream can be read using <code>str()</code>.
</p>

<p>
Use <code>stringstream</code> for in-memory formatting.
</p>
</div>
</div>

<div id="outline-container-org04f4191" class="outline-2">
<h2 id="org04f4191"><span class="section-number-2">9.</span> Containers</h2>
<div class="outline-text-2" id="text-9">
<p>
typical implementation of vector:
</p>
<ul class="org-ul">
<li>elem : a handle holding pointers to the first element</li>
<li>space : one-past-the-last element</li>
<li>last : one-past-the-last allocated space</li>
<li>alloc : allocator from which can acquire memory for elements</li>
</ul>

<p>
Initilize:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">v1</span> = <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">3</span>, <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">size is 4</span>
  <span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">v2</span>;             <span class="org-comment-delimiter">// </span><span class="org-comment">size is 0</span>
  <span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Shape</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">v3</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">23</span><span class="org-rainbow-delimiters-depth-1">)</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">size is 23; initial element value: nullptr</span>
  <span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">v4</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">32</span>, <span class="org-highlight-numbers-number">9.9</span><span class="org-rainbow-delimiters-depth-1">)</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">size is 32; initial element value: 9.9</span>
</pre>
</div>

<p>
A vector can be copied in assignments and initializations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Entry<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">book2</span> = phone_book;
</pre>
</div>

<p>
When you insert a new element, its value is copied into the container.
</p>

<p>
The <code>at()</code> operation throws an exception of type <code>out_of_range</code>
if its argument is out of the vector&rsquo;s range.
</p>

<p>
<code>list</code> : doubly-linked list.
</p>

<p>
<code>map</code> : a search tree (a red-black tree).
</p>

<p>
If a key isn’t found with <code>[]</code>, it is inserted into the <code>map</code> with a default value for its value.
</p>

<p>
<code>nordered_map</code>.
The standard-library provides a default hash function for strings
as well as for other built-in and standard-library types.
If necessary, you can provide your own.
</p>

<p>
A hash function is often provided as a function object:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">struct</span> <span class="org-type">Record</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">string</span> <span class="org-variable-name">name</span>;
    <span class="org-type">int</span> <span class="org-variable-name">product_code</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">a hash function for Record</span>
  <span class="org-keyword">struct</span> <span class="org-type">Rhash</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">size_t</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Record</span> &amp;<span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> hash<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;()(</span>r.name<span class="org-rainbow-delimiters-depth-3">)</span> ^ hash<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;()(</span>r.product_code<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">set of Recoreds using Rhash for lookup</span>
  <span class="org-type">unordered_set</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Record</span>, <span class="org-type">Rhash</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">my_set</span>;
</pre>
</div>

<p>
Creaing a new hash function by combining existing hash functions
using exclusive or (^) is simple and often very effective.
</p>

<ul class="org-ul">
<li>vector&lt;T&gt;, list&lt;T&gt;, forward_list&lt;T&gt;</li>
<li>map&lt;K,V&gt;, multimap&lt;K,V&gt;, unordered_map&lt;K,V&gt;, unordered_multimap&lt;K,V&gt;</li>
<li>set&lt;T&gt;, multiset&lt;T&gt;, unordered_set&lt;T&gt; unordered_multiset&lt;T&gt;</li>
<li>deque&lt;T&gt;, queue&lt;T&gt;, stack&lt;T&gt;, priority_queue&lt;T&gt;</li>
<li>fixed-size array <code>array&lt;T,N&gt;</code>, bitset&lt;N&gt;</li>
</ul>

<p>
Please note that a vector is usually more efficient than a list
for short sequences of small elements (even for insert() and erase()).
</p>

<p>
Use <code>forward_list</code> for sequences that are usually empty.
</p>

<p>
When it comes to performance, don’t trust your intuition: measure.
</p>

<p>
Pass a container by reference and return a container by value.
</p>
</div>
</div>

<div id="outline-container-org34e8a09" class="outline-2">
<h2 id="org34e8a09"><span class="section-number-2">10.</span> Algorithms</h2>
<div class="outline-text-2" id="text-10">
<div class="org-src-container">
<pre class="src src-c++">  sort<span class="org-rainbow-delimiters-depth-1">(</span>vec.begin<span class="org-rainbow-delimiters-depth-2">()</span>, vec.end<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  unique_copy<span class="org-rainbow-delimiters-depth-1">(</span>vec.begin<span class="org-rainbow-delimiters-depth-2">()</span>, vec.end<span class="org-rainbow-delimiters-depth-2">()</span>, lst.begin<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  unique_copy<span class="org-rainbow-delimiters-depth-1">(</span>vec.begin<span class="org-rainbow-delimiters-depth-2">()</span>, vec.end<span class="org-rainbow-delimiters-depth-2">()</span>, back_inserter<span class="org-rainbow-delimiters-depth-2">(</span>lst<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++">   <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span>find<span class="org-rainbow-delimiters-depth-2">(</span>s.begin<span class="org-rainbow-delimiters-depth-3">()</span>, s.end<span class="org-rainbow-delimiters-depth-3">()</span>, c<span class="org-rainbow-delimiters-depth-2">)</span> != s.end<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>
     <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span>;
</pre>
</div>

<p>
each container knows its iterator types and makes them available
under the conventional names <code>iterator</code> and <code>const_iterator</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">C</span>, <span class="org-keyword">typename</span> <span class="org-type">V</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-constant">C</span>::<span class="org-type">iterator</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-function-name">find_all</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">C</span> &amp;<span class="org-variable-name">c</span>, <span class="org-type">V</span> <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
</pre>
</div>

<p>
The typename is needed to inform the compiler that
C&rsquo;s iterator is supposed to be a type and not a value of some type.
</p>

<p>
With aliases:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">Iterator</span> = <span class="org-keyword">typename</span> <span class="org-constant">T</span>::iterator;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">C</span>, <span class="org-keyword">typename</span> <span class="org-type">V</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Iterator</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-function-name">find_all</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">C</span>&amp; <span class="org-variable-name">c</span>, <span class="org-type">V</span> <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
</pre>
</div>

<p>
Stream iterator:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">ostream_iterator</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">oo</span><span class="org-rainbow-delimiters-depth-2">{</span>cout<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">write strings to cout</span>
    *oo = <span class="org-string">"Hello, "</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">meaning cout&lt;&lt;"Hello, "</span>
    ++oo;
    *oo = <span class="org-string">"world!\n"</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">meaning cout&lt;&lt;"world!\n"</span>
    <span class="org-type">istream_iterator</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">ii</span><span class="org-rainbow-delimiters-depth-2">{</span>cin<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">istream_iterator</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">eos</span><span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">indicate the end of input</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Manipulate files:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">int</span> <span class="org-function-name">unique_copy</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">string</span> <span class="org-variable-name">from</span>, <span class="org-type">string</span> <span class="org-variable-name">to</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">ifstream</span> <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-2">{</span>from<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">ofstream</span> <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">{</span>to<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">set</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-type">istream_iterator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;{</span>is<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-type">istream_iterator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    copy<span class="org-rainbow-delimiters-depth-2">(</span>b.begin<span class="org-rainbow-delimiters-depth-3">()</span>, b.end<span class="org-rainbow-delimiters-depth-3">()</span>, <span class="org-type">ostream_iterator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;{</span>os, <span class="org-string">"\n"</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> <span class="org-negation-char">!</span>is.eof<span class="org-rainbow-delimiters-depth-2">()</span> || <span class="org-negation-char">!</span>os;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Predictors:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">struct</span> <span class="org-type">Greater_than</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">val</span>;
    <span class="org-function-name">Greater_than</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> : val<span class="org-rainbow-delimiters-depth-2">{</span>v<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{}</span>
    <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">pair</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">string</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> &amp;<span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> r.second &gt; val; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">use as</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">p</span> = find_if<span class="org-rainbow-delimiters-depth-1">(</span>m.begin<span class="org-rainbow-delimiters-depth-2">()</span>, m.end<span class="org-rainbow-delimiters-depth-2">()</span>, Greater_than<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">42</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">or lambda</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">p</span> = find_if<span class="org-rainbow-delimiters-depth-1">(</span>m.begin<span class="org-rainbow-delimiters-depth-2">()</span>, m.end<span class="org-rainbow-delimiters-depth-2">()</span>, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-keyword">const</span> <span class="org-type">pair</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">string</span>,<span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> r.second&gt;<span class="org-highlight-numbers-number">42</span>; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
A predicate must not modify its argument.
</p>

<p>
Functions in <code>&lt;algorithm&gt;</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  p = find<span class="org-rainbow-delimiters-depth-1">(</span>b, e, x<span class="org-rainbow-delimiters-depth-1">)</span>;
  p = find_if<span class="org-rainbow-delimiters-depth-1">(</span>b, e, f<span class="org-rainbow-delimiters-depth-1">)</span>;
  n = count<span class="org-rainbow-delimiters-depth-1">(</span>b, e, x<span class="org-rainbow-delimiters-depth-1">)</span>;
  n = count_if<span class="org-rainbow-delimiters-depth-1">(</span>b, e, f<span class="org-rainbow-delimiters-depth-1">)</span>;
  replace<span class="org-rainbow-delimiters-depth-1">(</span>b, e, v, v2<span class="org-rainbow-delimiters-depth-1">)</span>;
  replace_if<span class="org-rainbow-delimiters-depth-1">(</span>b, e, f, v2<span class="org-rainbow-delimiters-depth-1">)</span>;
  p = copy<span class="org-rainbow-delimiters-depth-1">(</span>b, e, out<span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">from [b:e) to [out:p)</span>
  p = copy_if<span class="org-rainbow-delimiters-depth-1">(</span>b, e, out, f<span class="org-rainbow-delimiters-depth-1">)</span>;
  p = move<span class="org-rainbow-delimiters-depth-1">(</span>b, e, out<span class="org-rainbow-delimiters-depth-1">)</span>;
  p = unique_copy<span class="org-rainbow-delimiters-depth-1">(</span>b, e, out<span class="org-rainbow-delimiters-depth-1">)</span>;
  sort<span class="org-rainbow-delimiters-depth-1">(</span>b, e<span class="org-rainbow-delimiters-depth-1">)</span>;
  sort<span class="org-rainbow-delimiters-depth-1">(</span>b, e, f<span class="org-rainbow-delimiters-depth-1">)</span>;                   <span class="org-comment-delimiter">// </span><span class="org-comment">Sort elements of [b:e) using f</span>
  <span class="org-rainbow-delimiters-depth-1">(</span>p1, p2<span class="org-rainbow-delimiters-depth-1">)</span> = equal_range<span class="org-rainbow-delimiters-depth-1">(</span>b, e, v<span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">[p1:p2) is the subsequence with the value v</span>
  p = merge<span class="org-rainbow-delimiters-depth-1">(</span>b, e, b2, e2, out<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Some algorithms, such as <code>replace()</code> and <code>sort()</code>, modify element values,
But <b>no algorithm add or subtract elements</b> of a container.
</p>

<p>
If you want to add elements, you need something,
such as an <code>back_inserter</code> that knows about the container.
</p>
</div>
</div>

<div id="outline-container-org412be84" class="outline-2">
<h2 id="org412be84"><span class="section-number-2">11.</span> Utilities</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org4195cee" class="outline-3">
<h3 id="org4195cee"><span class="section-number-3">11.1.</span> Smart Pointers</h3>
<div class="outline-text-3" id="text-11-1">
<p>
In <code>&lt;memory&gt;</code>, the stan- dard library provides two 
smart pointers to help manage objects on the free store:
</p>
<ol class="org-ol">
<li><code>unique_ptr</code> to represent unique ownership</li>
<li><code>shared_ptr</code> to represent shared ownership</li>
</ol>

<p>
The <code>shared_ptr</code> is similar to <code>unique_ptr</code> except that
shared_ptrs are <b>copied rather than moved</b>.
</p>

<p>
The shared_ptrs for an object share ownership of an object and
that object is destroyed when the last of its shared_ptrs is destroyed.
</p>

<p>
the standard library (in <code>&lt;memory&gt;</code>) provides a function <code>make_shared()</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>S<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">p1</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-keyword">new</span> <span class="org-type">S</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>, <span class="org-string">"Ankh Morpork"</span>, <span class="org-highlight-numbers-number">4.65</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">p2</span> = make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>S<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-highlight-numbers-number">2</span>, <span class="org-string">"Oz"</span>, <span class="org-highlight-numbers-number">7.62</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Use <code>unique_ptr</code> to refer to objects of polymorphic type.
Use <code>shared_ptr</code> to refer to shared objects.
</p>
</div>
</div>

<div id="outline-container-orgef015fd" class="outline-3">
<h3 id="orgef015fd"><span class="section-number-3">11.2.</span> Specialized Containers</h3>
<div class="outline-text-3" id="text-11-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Almost Conainers</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Container</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T[N]</td>
<td class="org-left">Built-in array</td>
</tr>

<tr>
<td class="org-left">array&lt;T,N&gt;</td>
<td class="org-left">Like the built-in array, but <b>with most problems solved</b></td>
</tr>

<tr>
<td class="org-left">bitset&lt;N&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">vector&lt;bool&gt;</td>
<td class="org-left">A sequence of bits <b>compactly</b> stored in a specialization of vector</td>
</tr>

<tr>
<td class="org-left">pair&lt;T,U&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">tuple&lt;T&#x2026;&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">basic_string&lt;C&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">valarray&lt;T&gt;</td>
<td class="org-left">An array of numeric values of type T; provides numeric operations</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orga5f2050" class="outline-4">
<h4 id="orga5f2050"><span class="section-number-4">11.2.1.</span> array</h4>
<div class="outline-text-4" id="text-11-2-1">
<p>
An array, defined in <code>&lt;array&gt;</code>, is a fixed-size sequence of elements of a given type
where <b>the number of elements is specified at compile time</b>.
</p>

<p>
Thus, an array can be allocated with its elements on the stack,
in an object, or in static storage.
</p>

<p>
There is no overhead (time or space) involved in using an array
compared to using a built-in array.
</p>

<p>
An array knows its size, can be copied (using = or initialization),
and saves one from surprising nasty conversions to pointers.
</p>

<p>
An array does not &ldquo;handle to elements.&rdquo;
</p>

<p>
The element count is not optional:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">array</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">ax</span> = <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
an array can be explicitly passed to a C-style function that expects a pointer:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>&#8727; p, <span class="org-type">int</span> <span class="org-variable-name">sz</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">C-style interface</span>
  <span class="org-type">void</span> <span class="org-function-name">g</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">array</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">a</span>;
    f<span class="org-rainbow-delimiters-depth-2">(</span>a, a.size<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;                         <span class="org-comment-delimiter">// </span><span class="org-comment">error: no conversion</span>
    f<span class="org-rainbow-delimiters-depth-2">(</span>&amp;a<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">]</span>, a.size<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;                     <span class="org-comment-delimiter">// </span><span class="org-comment">C-style use</span>
    f<span class="org-rainbow-delimiters-depth-2">(</span>a.data<span class="org-rainbow-delimiters-depth-3">()</span>, a.size<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;                  <span class="org-comment-delimiter">// </span><span class="org-comment">C-style use</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">p</span> = find<span class="org-rainbow-delimiters-depth-2">(</span>a.begin<span class="org-rainbow-delimiters-depth-3">()</span>, a.end<span class="org-rainbow-delimiters-depth-3">()</span>, <span class="org-highlight-numbers-number">777</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">C++/STL-style use</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5fd4a51" class="outline-4">
<h4 id="org5fd4a51"><span class="section-number-4">11.2.2.</span> bitset</h4>
<div class="outline-text-4" id="text-11-2-2">
<p>
A <code>bitset</code> can be initialized with an integer or a string:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-highlight-numbers-number">9</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">bs1</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"110001111"</span><span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-highlight-numbers-number">9</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">bs2</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">399</span><span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-highlight-numbers-number">9</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">bs3</span> =  &#771;bs1;
  <span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-highlight-numbers-number">9</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">bs4</span> = bs1 &amp; bs3;
  <span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-highlight-numbers-number">9</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">bs5</span> = bs1 &lt;&lt; <span class="org-highlight-numbers-number">2</span>;
</pre>
</div>

<p>
<code>to_ullong()</code> and <code>to_string()</code> provide the inverse operations to the constructors.
</p>
</div>
</div>

<div id="outline-container-org15cb8e0" class="outline-4">
<h4 id="org15cb8e0"><span class="section-number-4">11.2.3.</span> pair and tuple</h4>
<div class="outline-text-4" id="text-11-2-3">
<p>
The make_pair() / make_tuple() function makes it easy to create
a pair / tuple without explicitly mentioning its type.
</p>

<p>
Elements of tuple can be accessed by <code>get&lt;0&gt;(t), get&lt;1&gt;(t), get&lt;2&gt;(t)</code>.
</p>
</div>
</div>

<div id="outline-container-orgdc44f40" class="outline-4">
<h4 id="orgdc44f40"><span class="section-number-4">11.2.4.</span> Time</h4>
<div class="outline-text-4" id="text-11-2-4">
<p>
The standard-library facilities for dealing with time
are found in the subnamespace <code>std::chrono</code> in <code>&lt;chrono&gt;</code>.
</p>

<p>
Timing something:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">t0</span> = <span class="org-constant">high_resolution_clock</span>::now<span class="org-rainbow-delimiters-depth-1">()</span>;
  do_work<span class="org-rainbow-delimiters-depth-1">()</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">t1</span> = <span class="org-constant">high_resolution_clock</span>::now<span class="org-rainbow-delimiters-depth-1">()</span>;
  cout &lt;&lt; duration_cast<span class="org-rainbow-delimiters-depth-1">&lt;</span>milliseconds<span class="org-rainbow-delimiters-depth-1">&gt;(</span>t1&#8722;t0<span class="org-rainbow-delimiters-depth-1">)</span>.count<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-string">"msec\n"</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org7943471" class="outline-4">
<h4 id="org7943471"><span class="section-number-4">11.2.5.</span> Function</h4>
<div class="outline-text-4" id="text-11-2-5">
<p>
A function adaptor takes a function as argument and returns a function object
that can be used to invoke the original function.
</p>

<p>
The standard library provides <code>bind()</code> and <code>mem_fn()</code> adaptors to do argument binding,
also called <i>Currying</i> or <i>partial evaluation</i>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
  <span class="org-type">void</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>, <span class="org-keyword">const</span> <span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = bind<span class="org-rainbow-delimiters-depth-1">(</span>f, <span class="org-highlight-numbers-number">2</span>, <span class="org-constant">placeholders</span>::<span class="org-constant">_1</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">bind f()&#8217;s first argument to 2</span>
  f<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">2</span>, <span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  g<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Use <code>mem_fn()</code> to create function objects that can invoke a member function
when called using the traditional function call notation.
</p>
<div class="org-src-container">
<pre class="src src-c++">  p&#8722;&gt; draw<span class="org-rainbow-delimiters-depth-1">()</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">draw</span> = mem_fn<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Shape</span>::draw<span class="org-rainbow-delimiters-depth-1">)</span>;
  draw<span class="org-rainbow-delimiters-depth-1">(</span>p<span class="org-rainbow-delimiters-depth-1">)</span>;

  for_each<span class="org-rainbow-delimiters-depth-1">(</span>v.begin<span class="org-rainbow-delimiters-depth-2">()</span>, v.end<span class="org-rainbow-delimiters-depth-2">()</span>, mem_fn<span class="org-rainbow-delimiters-depth-2">(</span>&amp;<span class="org-constant">Shape</span>::draw<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Often, a lambda is an alternative to using <code>bind()</code> or <code>mem_fn()</code>.
</p>

<p>
A <code>function</code> is specified with a specific return type and a specific argument type:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">int</span> <span class="org-function-name">f1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">fct</span><span class="org-rainbow-delimiters-depth-1">{</span>f1<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">initialize to f1</span>

  <span class="org-type">void</span> <span class="org-function-name">user</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    fct = <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">double</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> round<span class="org-rainbow-delimiters-depth-3">(</span>d<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">assign lambda to fct</span>
    fct = f1;                                <span class="org-comment-delimiter">// </span><span class="org-comment">assign function to fct</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Use function when you need to store something that can be called.
</p>

<p>
A type function is a function that is evaluated at compile-time
given a type as its argument or returning a type.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">limits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
  <span class="org-keyword">constexpr</span> <span class="org-type">float</span> <span class="org-variable-name">min</span> = <span class="org-constant">numeric_limits</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::min<span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">smallest positive float</span>
</pre>
</div>

<p>
Metaprogramming or (when templates are involved) template metaprogramming.
</p>

<p>
<code>iterator_trait</code>, tag dispatch, type predicates.
</p>

<p>
<code>&lt;type_traits&gt;</code> : is_arithmetic, is_class, is_pod, is_literal_type,
has_virtual_destructor, and is_base_of.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2b76d49" class="outline-2">
<h2 id="org2b76d49"><span class="section-number-2">12.</span> Numerics</h2>
<div class="outline-text-2" id="text-12">
<p>
<code>&lt;math&gt;</code> for float, double, long double :
abs(x), ceil(x), floor(x), sqrt(x), cos(x), sin(x),
tan(x), acos(x), asin(x), sinh(x), cosh(x), tanh(x),
exp(x), log(x).
</p>

<p>
The versions for <code>complex</code> are found in <code>&lt;complex&gt;</code>.
</p>

<p>
Errors are reported by setting errno from <code>&lt;cerrno&gt;</code> to <code>EDOM</code>
for a domain error and to <code>ERANGE</code> for a range error:
</p>
<div class="org-src-container">
<pre class="src src-c++">  errno = <span class="org-highlight-numbers-number">0</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">clear old error state</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span>errno == <span class="org-constant">EDOM</span><span class="org-rainbow-delimiters-depth-1">)</span> cerr &lt;&lt; <span class="org-string">"domain error"</span>;
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span>errno == <span class="org-constant">ERANGE</span><span class="org-rainbow-delimiters-depth-1">)</span> cerr &lt;&lt; <span class="org-string">"range error"</span>;
</pre>
</div>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Numerical Algorithms in <code>&lt;numeric&gt;</code></caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">x=accumulate(b,e,i)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">x=accumulate(b,e,i,f)</td>
<td class="org-left">using f instead of +</td>
</tr>

<tr>
<td class="org-left">x=inner_product(b,e,b2,i)</td>
<td class="org-left">inner product of [b:e) and [b2:b2+(e−b)), i is initial value</td>
</tr>

<tr>
<td class="org-left">x=inner_product(b,e,b2,i,f,f2)</td>
<td class="org-left">using f and f2 instead of + and *</td>
</tr>

<tr>
<td class="org-left">p=partial_sum(b,e,out)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=partial_sum(b,e,out,f)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=adjacent_difference(b,e,out)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=adjacent_difference(b,e,out,f)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">iota(b,e,v)</td>
<td class="org-left">For each element in [b:e) assign ++v: v+1, v+2, &#x2026;</td>
</tr>
</tbody>
</table>

<p>
A random number generator consists of two parts:
</p>
<ol class="org-ol">
<li>an <b>engine</b> that produces a sequence of random or pseudo-random values.</li>
<li>a <b>distribution</b> that maps those values into a mathematical distribution in a range.</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">auto</span> <span class="org-variable-name">die</span> = bind<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">uniform_int_distribution</span><span class="org-rainbow-delimiters-depth-2">&lt;&gt;{</span><span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-2">}</span>,
                  default_random_engine<span class="org-rainbow-delimiters-depth-2">{}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-type">int</span> <span class="org-variable-name">x</span> = die<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
<code>valarray</code> in <code>&lt;valarray&gt;</code>  is less general and
more amenable to <b>optimization for numerical computation</b>.
</p>

<p>
Properties of numeric types are accessible through numeric_limits.
Use numeric_limits to check that the numeric types are adequate for their use.
</p>
</div>
</div>

<div id="outline-container-orgb6db38e" class="outline-2">
<h2 id="orgb6db38e"><span class="section-number-2">13.</span> Concurrency</h2>
<div class="outline-text-2" id="text-13">
<p>
threads, mutexes, lock() operations, packaged_tasks, and futures.
</p>

<p>
<b>task</b> s a computation that can potentially be executed concurrently with other computations.
A <b>thread</b> is the system-level representation of a task in a program.
</p>

<p>
A task is a function or a function object and launched as argument
by constructing a <code>std::thread</code> (found in <code>&lt;thread&gt;</code>).
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">()</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">function</span>
  <span class="org-keyword">struct</span> <span class="org-type">F</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-comment-delimiter">// </span><span class="org-comment">function object</span>
    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">user</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">thread</span> <span class="org-variable-name">t1</span><span class="org-rainbow-delimiters-depth-2">{</span>f<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">thread</span> <span class="org-variable-name">t2</span><span class="org-rainbow-delimiters-depth-2">{</span>F<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    t1.join<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">wait for t1</span>
    t2.join<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">wait for t2</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
To <code>join</code> a thread means to wait for the thread to terminate.
</p>

<p>
Threads of a program <b>share a single address space</b>.
In this, threads differ from processes, which generally do not directly share data.
Since threads share an address space, they can communicate through shared objects.
</p>

<p>
The <code>ref()</code> is a type function from <code>&lt;functional&gt;</code> that unfortunately is needed
to tell the variadic template to treat some_vec as a reference,
rather than as an object.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-type">thread</span> <span class="org-variable-name">t1</span><span class="org-rainbow-delimiters-depth-1">{</span>f, ref<span class="org-rainbow-delimiters-depth-2">(</span>some_vec<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
pass the input data by const reference and to
pass the location of a place to deposit the result as a separate argument:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">v</span>, <span class="org-type">double</span> *<span class="org-variable-name">res</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-type">thread</span> <span class="org-variable-name">t1</span><span class="org-rainbow-delimiters-depth-1">{</span>f, cref<span class="org-rainbow-delimiters-depth-2">(</span>some_vec<span class="org-rainbow-delimiters-depth-2">)</span>, &amp;res1<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<p>
<code>cref</code> is for <code>const</code>.
</p>

<p>
A <code>mutex</code> in <code>&lt;mutex&gt;</code> is a mutual exclusion object.
A thread acquires a mutex using a <code>lock()</code> operation:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">mutex</span> <span class="org-variable-name">m</span>;
  <span class="org-type">int</span> <span class="org-variable-name">sh</span>;
  <span class="org-type">void</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">lck</span><span class="org-rainbow-delimiters-depth-2">{</span>m<span class="org-rainbow-delimiters-depth-2">}</span>;
    sh += <span class="org-highlight-numbers-number">7</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">release mutex implicitly</span>
</pre>
</div>
<p>
The <code>unique_lock</code> releases the mutex with a call <code>m.unlock()</code>.
</p>

<p>
Acquiring several locks simultaneously to avoid deadlock:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">lck1</span> <span class="org-rainbow-delimiters-depth-1">{</span>m1,defer_lock<span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">lck2</span> <span class="org-rainbow-delimiters-depth-1">{</span>m2,defer_lock<span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">lck3</span> <span class="org-rainbow-delimiters-depth-1">{</span>m3,defer_lock<span class="org-rainbow-delimiters-depth-1">}</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  lock<span class="org-rainbow-delimiters-depth-1">(</span>lck1,lck2,lck3<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Sleep:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono</span>;
  <span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-1">(</span>milliseconds<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">20</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
The basic support for communicating using external events
is provided by condition_variables found in <code>&lt;condition_variable&gt;</code>.
A <code>condition_variable</code> is a mechanism allowing one thread to wait for another:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">queue</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Message<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">mqueue</span>;
  <span class="org-type">condition_variable</span> <span class="org-variable-name">mcond</span>;
  <span class="org-type">mutex</span> <span class="org-variable-name">mmutex</span>;

  <span class="org-type">void</span> <span class="org-function-name">consumer</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">lck</span><span class="org-rainbow-delimiters-depth-3">{</span>mmutex<span class="org-rainbow-delimiters-depth-3">}</span>;
      <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span>mcond.wait<span class="org-rainbow-delimiters-depth-4">(</span>lck<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">/* </span><span class="org-comment">do nothing</span><span class="org-comment-delimiter"> */</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">m</span> = mqueue.front<span class="org-rainbow-delimiters-depth-3">()</span>;
      mqueue.pop<span class="org-rainbow-delimiters-depth-3">()</span>;
      lck.unlock<span class="org-rainbow-delimiters-depth-3">()</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">process m...</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-type">void</span> <span class="org-function-name">producer</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-type">Message</span> <span class="org-variable-name">m</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">... fill the message ...</span>
      <span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">lck</span><span class="org-rainbow-delimiters-depth-3">{</span>mmutex<span class="org-rainbow-delimiters-depth-3">}</span>;
      mqueue.push<span class="org-rainbow-delimiters-depth-3">(</span>m<span class="org-rainbow-delimiters-depth-3">)</span>;
      mcond.notify_one<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<code>&lt;future&gt;</code>:
</p>
<ol class="org-ol">
<li>future and promise</li>
<li>packaged_task</li>
<li>async()</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">promise</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>X<span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">px</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-type">X</span> <span class="org-variable-name">res</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
      px.set_value<span class="org-rainbow-delimiters-depth-3">(</span>res<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-function-name">...</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      px.set_exception<span class="org-rainbow-delimiters-depth-3">(</span>current_exception<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">pass the exception</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-type">void</span> <span class="org-function-name">g</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">future</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">X</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">fx</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-type">X</span> <span class="org-variable-name">v</span> = fx.get<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">block</span><span class="org-comment-delimiter"> */</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The packaged_task type is provided to simplify setting up tasks
connected with futures and promises to be run on threads:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">double</span> <span class="org-function-name">accum</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span>&#8727; beg, <span class="org-type">double</span>&#8727; end, <span class="org-type">double</span> <span class="org-variable-name">init</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> accumulate<span class="org-rainbow-delimiters-depth-2">(</span>beg, end, init<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-type">double</span> <span class="org-function-name">sum</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">using</span> <span class="org-type">Task_type</span> = <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span>&#8727;, <span class="org-type">double</span>&#8727;, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">accumulate</span>
    <span class="org-type">packaged_task</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>Task_type<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">pt0</span><span class="org-rainbow-delimiters-depth-2">{</span>accum<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">packaged_task</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>Task_type<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">pt1</span><span class="org-rainbow-delimiters-depth-2">{</span>accum<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">future</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">f0</span><span class="org-rainbow-delimiters-depth-2">{</span>pt0.get_future<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">future</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">f1</span><span class="org-rainbow-delimiters-depth-2">{</span>pt1.get_future<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-type">double</span>&#8727; first = &amp;v<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">]</span>;
    <span class="org-type">thread</span> <span class="org-variable-name">t1</span><span class="org-rainbow-delimiters-depth-2">{</span>move<span class="org-rainbow-delimiters-depth-3">(</span>pt0<span class="org-rainbow-delimiters-depth-3">)</span>, first, first + v.size<span class="org-rainbow-delimiters-depth-3">()</span> / <span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">thread</span> <span class="org-variable-name">t2</span><span class="org-rainbow-delimiters-depth-2">{</span>move<span class="org-rainbow-delimiters-depth-3">(</span>pt1<span class="org-rainbow-delimiters-depth-3">)</span>, first + v.size<span class="org-rainbow-delimiters-depth-3">()</span> / <span class="org-highlight-numbers-number">2</span>, first + v.size<span class="org-rainbow-delimiters-depth-3">()</span>, <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">return</span> f0.get<span class="org-rainbow-delimiters-depth-2">()</span> + f1.get<span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Using <code>async()</code>, you don’t have to think about threads and locks.
Instead, you think just in terms of tasks that potentially compute their results asynchronously:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">auto</span> <span class="org-variable-name">v0</span> = &amp;v<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">]</span>; <span class="org-keyword">auto</span> <span class="org-variable-name">sz</span> = v.size<span class="org-rainbow-delimiters-depth-1">()</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">f0</span> = async<span class="org-rainbow-delimiters-depth-1">(</span>accum, v0, v0 + sz / <span class="org-highlight-numbers-number">4</span>, <span class="org-highlight-numbers-number">0.0</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">f1</span> = async<span class="org-rainbow-delimiters-depth-1">(</span>accum, v0 + sz / <span class="org-highlight-numbers-number">4</span>, v0 + sz / <span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">0.0</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">f2</span> = async<span class="org-rainbow-delimiters-depth-1">(</span>accum, v0 + sz / <span class="org-highlight-numbers-number">2</span>, v0 + sz&#8727;3 / <span class="org-highlight-numbers-number">4</span>, <span class="org-highlight-numbers-number">0.0</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">f3</span> = async<span class="org-rainbow-delimiters-depth-1">(</span>accum, v0 + sz&#8727;3 / <span class="org-highlight-numbers-number">4</span>, v0 + sz, <span class="org-highlight-numbers-number">0.0</span><span class="org-rainbow-delimiters-depth-1">)</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">f0.get() + f1.get() + f2.get() + f3.get();</span>
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
