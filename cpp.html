<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-16 Sun 17:39 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Note of "A Tour of C++"</title>
<meta name="author" content="shen chao" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Note of &ldquo;A Tour of C++&rdquo;</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org065b363">1. The Basics</a></li>
<li><a href="#org98d4845">2. User-Defined Types</a></li>
<li><a href="#org1ae875a">3. Modularity</a></li>
<li><a href="#org5a927db">4. Classes</a>
<ul>
<li><a href="#org3950cb4">4.1. Dynamic Casting</a></li>
<li><a href="#org5f962b0">4.2. Copy and Move</a></li>
<li><a href="#org7e9f2e2">4.3. Essential Operations</a></li>
</ul>
</li>
<li><a href="#orge658430">5. Templates</a></li>
<li><a href="#orgaeded69">6. Library Overview</a></li>
<li><a href="#orgee97bdb">7. Strings and Regular Expressions</a>
<ul>
<li><a href="#org27deb10">7.1. Regular Expressions</a></li>
</ul>
</li>
<li><a href="#org7fd2dbe">8. I/O Streams</a></li>
<li><a href="#org3a4d79b">9. Containers</a></li>
<li><a href="#org553a6c0">10. Algorithms</a></li>
<li><a href="#orgdfc8358">11. Utilities</a>
<ul>
<li><a href="#org5d99a47">11.1. Smart Pointers</a></li>
<li><a href="#org7ab8b8d">11.2. Specialized Containers</a></li>
</ul>
</li>
<li><a href="#org16c5a7f">12. Numerics</a></li>
<li><a href="#orga8233f9">13. Concurrency</a></li>
</ul>
</div>
</div>

<div id="outline-container-org065b363" class="outline-2">
<h2 id="org065b363"><span class="section-number-2">1.</span> The Basics</h2>
<div class="outline-text-2" id="text-1">
<p>
The minimal C++ program:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-function-name">main</span>() { }
</pre>
</div>

<p>
If no value is returned, the system will receive a value
indicating successful completion.
</p>

<p>
A function declaration may contain argument names.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">double</span> <span class="org-function-name">square</span>(<span class="org-type">double</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">return the square of the argument</span>
</pre>
</div>

<p>
If two functions are defined with the same name,
 but with different argument types,
 the compiler will choose the most appropriate function to invoke for each call.
</p>

<p>
Fundamental types: bool, char, int, double, unsigned.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-right">sizeof</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bool, char</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-right">8</td>
</tr>
</tbody>
</table>

<p>
<i>The usual arithmetic conversions: expressions
 are computed at the highest precision of its operands.</i>
</p>

<p>
Universal form based on curly-brace-delimited initializer lists:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-type">double</span> <span class="org-variable-name">d2</span> {<span class="org-highlight-numbers-number">2.3</span>};
  <span class="org-type">complex</span>&lt;<span class="org-type">double</span>&gt; <span class="org-variable-name">z3</span> = {<span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">2</span>}; <span class="org-comment-delimiter">// </span><span class="org-comment">the = is optional with { ... }</span>
</pre>
</div>

<p>
<code>auto</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">auto</span> <span class="org-variable-name">b</span> = <span class="org-constant">true</span>;
</pre>
</div>

<p>
<i>Range-for-statement</i>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">int</span> <span class="org-variable-name">v</span>[] = {<span class="org-highlight-numbers-number">0</span>,<span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">2</span>,<span class="org-highlight-numbers-number">3</span>,<span class="org-highlight-numbers-number">4</span>,<span class="org-highlight-numbers-number">5</span>,<span class="org-highlight-numbers-number">6</span>,<span class="org-highlight-numbers-number">7</span>,<span class="org-highlight-numbers-number">8</span>,<span class="org-highlight-numbers-number">9</span>};
<span class="org-keyword">for</span> (<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span> : v) cout &lt;&lt; x &lt;&lt; <span class="org-string">'\n'</span>;
</pre>
</div>

<p>
Use <code>nullptr</code> rather than <code>0</code> or <code>NULL</code>.
</p>

<p>
Prefer the <code>{}</code>-initializer syntax for declarations with a named type,
prefer the <code>=</code> syntax for the initialization in declarations using <code>auto</code>.
</p>
</div>
</div>

<div id="outline-container-org98d4845" class="outline-2">
<h2 id="org98d4845"><span class="section-number-2">2.</span> User-Defined Types</h2>
<div class="outline-text-2" id="text-2">
<p>
A <code>struct</code> is simply a class with members public by default:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">V</span>{ <span class="org-type">int</span> <span class="org-variable-name">val</span>; };
</pre>
</div>

<p>
Class:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Vector</span> {
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Vector</span>(<span class="org-type">int</span> <span class="org-variable-name">s</span>) : elem{<span class="org-keyword">new</span> <span class="org-type">double</span>[s]}, sz{s} {} <span class="org-comment-delimiter">// </span><span class="org-comment">member initializer list</span>
    <span class="org-type">double</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">[]</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) { <span class="org-keyword">return</span> elem[i]; } <span class="org-comment-delimiter">// </span><span class="org-comment">operation</span>
    <span class="org-type">int</span> <span class="org-function-name">size</span>() { <span class="org-keyword">return</span> sz; }

  <span class="org-keyword">private</span>:
    <span class="org-type">double</span>* <span class="org-variable-name">elem</span>;
    <span class="org-type">int</span> <span class="org-variable-name">sz</span>;
  };
</pre>
</div>

<p>
A <code>union</code> is a <code>struct</code> in which all members are allocated at the same address
so that the <code>union</code> occupies only as much space as its largest member.
Naturally, a <code>union</code> can hold a value for only one member at a time.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">union</span> <span class="org-type">Value</span> {
    <span class="org-type">char</span>* <span class="org-variable-name">s</span>;
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
  };
</pre>
</div>


<p>
Enumeration:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Color</span> { <span class="org-variable-name">red</span>, <span class="org-variable-name">blue</span>, <span class="org-variable-name">green</span> };
<span class="org-type">Color</span> <span class="org-variable-name">col</span> = <span class="org-constant">Color</span>::red;
</pre>
</div>

<p>
An enumeration is a user-defined type so we can define operators for it.
You can remove the <code>class</code> from <code>enum</code> class to get a plain <code>enum</code>
(<code>int</code> value starts with 0).
</p>
</div>
</div>

<div id="outline-container-org1ae875a" class="outline-2">
<h2 id="org1ae875a"><span class="section-number-2">3.</span> Modularity</h2>
<div class="outline-text-2" id="text-3">
<p>
Declarations / interfaces, <code>Vector.h</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Vector</span> {
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Vector</span>(<span class="org-type">int</span> <span class="org-variable-name">s</span>);
    <span class="org-type">double</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">[]</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>);
    <span class="org-type">int</span> <span class="org-function-name">size</span>();
  <span class="org-keyword">private</span>:
    <span class="org-type">double</span>* <span class="org-variable-name">elem</span>;
  };
</pre>
</div>

<p>
Avoid non-inline function definitions in headers.
</p>

<p>
Definitions / implementations, <code>Vector.cpp</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span> <span class="org-string">"Vector.h"</span>
  <span class="org-constant">Vector</span>::<span class="org-function-name">Vector</span>(<span class="org-type">int</span> <span class="org-variable-name">s</span>) :elem{<span class="org-keyword">new</span> <span class="org-type">double</span>[s]}, sz{s} { }
  <span class="org-type">double</span>&amp; <span class="org-constant">Vector</span>::<span class="org-keyword">operator</span><span class="org-function-name">[]</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) { <span class="org-keyword">return</span> elem[i]; }
  <span class="org-type">int</span> <span class="org-constant">Vector</span>::<span class="org-function-name">size</span>() { <span class="org-keyword">return</span> sz; }
</pre>
</div>

<p>
Namespaces:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">namespace</span> <span class="org-constant">My_code</span> {
    <span class="org-keyword">class</span> <span class="org-type">complex</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    };
    <span class="org-type">complex</span> <span class="org-function-name">sqrt</span>(<span class="org-type">complex</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-type">int</span> <span class="org-function-name">main</span>();
  }
  <span class="org-type">int</span> <span class="org-constant">My_code</span>::<span class="org-function-name">main</span>(){
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  };
</pre>
</div>

<p>
Don&rsquo;t put a using-directive in a header file.
</p>

<p>
Exceptions:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span><span class="org-string">&lt;stdexcept&gt;</span>
  <span class="org-keyword">throw</span> out_of_range{<span class="org-string">"Vector::operator[]"</span>};

  <span class="org-keyword">try</span> { <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span> }
  <span class="org-keyword">catch</span> (out_of_range) { <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span> }
  <span class="org-keyword">catch</span> (<span class="org-function-name">...</span>) { <span class="org-comment-delimiter">/* </span><span class="org-comment">any exception</span><span class="org-comment-delimiter"> */</span> }
</pre>
</div>

<p>
Logic errors: <code>logic_error</code>, <code>domain_error</code>, <code>invalid_argument</code>, <code>length_error</code>, <code>out_of_range</code>.
</p>

<p>
Runtime errors: <code>runtime_error</code>, <code>range_error</code>, <code>overflow_error</code>, <code>underflow_error</code>.
</p>

<p>
A function that should never throw an exception can be declared noexcept:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">user</span>(<span class="org-type">int</span> <span class="org-variable-name">sz</span>) <span class="org-keyword">noexcept</span>;
</pre>
</div>

<p>
If still throws, the standard-library function <code>terminate()</code>
 is called to immediately terminate the program.
</p>

<p>
If operator <code>new</code> can&rsquo;t find memory to allocate, it throws a <code>std::bad_alloc</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">try</span> { <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span> }
  <span class="org-keyword">catch</span> (<span class="org-constant">std</span>::bad_alloc) {
    <span class="org-constant">std</span>::terminate(); <span class="org-comment-delimiter">// </span><span class="org-comment">handle memory exhaustion</span>
  }
</pre>
</div>

<p>
To rethrow the exception, we simply write <code>throw</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">catch</span> (<span class="org-constant">std</span>::length_error) {
    cout &lt;&lt; <span class="org-string">"test failed: length error\n"</span>;
    <span class="org-keyword">throw</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">rethrow</span>
  }
</pre>
</div>

<p>
Compile time check:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">static_assert</span>(<span class="org-highlight-numbers-number">4</span> &lt;= <span class="org-keyword">sizeof</span>(<span class="org-type">int</span>), <span class="org-string">"integers are too small"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org5a927db" class="outline-2">
<h2 id="org5a927db"><span class="section-number-2">4.</span> Classes</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>const</code> function:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">double</span> <span class="org-function-name">real</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> re; }
</pre>
</div>

<p>
Operations change object itself should return reference:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">complex</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">+=</span>(<span class="org-type">complex</span> <span class="org-variable-name">z</span>) { re+=z.re, im+=z.im; <span class="org-keyword">return</span> *<span class="org-keyword">this</span>; }
</pre>
</div>

<p>
Functions defined in a class are inlined by default.
It is possible to explicitly require inlining by
preceeding a function declaration with the keyword <code>inline</code>.
</p>

<p>
Clever ways of implementing operations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  complex <span class="org-keyword">operator</span>&#8722;(<span class="org-type">complex</span> <span class="org-variable-name">a</span>, <span class="org-type">complex</span> <span class="org-variable-name">b</span>) { <span class="org-keyword">return</span> a &#8722;= b; }
  <span class="org-comment-delimiter">// </span><span class="org-comment">unary minus</span>
  complex <span class="org-keyword">operator</span>&#8722;(<span class="org-type">complex</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> {&#8722;a.real(), &#8722;a.imag()}; }
</pre>
</div>

<p>
Destructor:
</p>
<div class="org-src-container">
<pre class="src src-c++">  ~<span class="org-function-name">Vector</span>() { <span class="org-keyword">delete</span>[] elem; }
</pre>
</div>

<p>
Initializer-list constructor:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-constant">Vector</span>::<span class="org-function-name">Vector</span>(<span class="org-constant">std</span>::<span class="org-type">initializer_list</span>&lt;<span class="org-type">double</span>&gt; <span class="org-variable-name">lst</span>)
      : elem{<span class="org-keyword">new</span> <span class="org-type">double</span>[lst.size()]}, sz{<span class="org-keyword">static_cast</span>&lt;<span class="org-type">int</span>&gt;(lst.size())} {
    copy(lst.begin(), lst.end(), elem);
  }
</pre>
</div>

<p>
<code>push_back</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Vector</span> <span class="org-function-name">read</span>(<span class="org-type">istream</span> &amp;<span class="org-variable-name">is</span>) {
    <span class="org-type">Vector</span> <span class="org-variable-name">v</span>;
    <span class="org-keyword">for</span> (<span class="org-type">double</span> <span class="org-variable-name">d</span>; is &gt;&gt; d;)
      v.push_back(d);
    <span class="org-keyword">return</span> v;
  }
</pre>
</div>

<p>
Abstract type:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Container</span> {
  <span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">pure virtual function</span>
    <span class="org-keyword">virtual</span> <span class="org-type">double</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">[]</span>(<span class="org-type">int</span>) = <span class="org-highlight-numbers-number">0</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">const member function</span>
    <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">size</span>() <span class="org-keyword">const</span> = <span class="org-highlight-numbers-number">0</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">destructor</span>
    <span class="org-keyword">virtual</span>  ~<span class="org-function-name">Container</span>() {}
  };
</pre>
</div>

<p>
The word <code>virtual</code> means &ldquo;may be redefined later in a class derived from this one.&rdquo;
</p>

<p>
The curious <code>=0</code> syntax says the function is pure virtual;
that is, some class derived from <code>Container</code> <b>must</b> define the function.
</p>

<p>
A class with a pure virtual function is called an abstract class
and it&rsquo;s not possible to define an object of it.
</p>

<p>
As is common for abstract class, it does <b>not</b> have a constructor.
On the other hand, it <b>does</b> have a destructor and that destructor is <code>virtual</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Vector_container</span> : <span class="org-keyword">public</span> <span class="org-type">Container</span> {
    <span class="org-type">Vector</span> <span class="org-variable-name">v</span>;

  <span class="org-keyword">public</span>:
    <span class="org-function-name">Vector_container</span>(<span class="org-type">int</span> <span class="org-variable-name">s</span>) : v(s) {}
    ~<span class="org-function-name">Vector_container</span>() {}
    <span class="org-type">double</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">[]</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) { <span class="org-keyword">return</span> v[i]; }
    <span class="org-type">int</span> <span class="org-function-name">size</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> v.size(); }
  };
</pre>
</div>

<p>
Note that the member destructor (<code>~Vector()</code>) is implicitly invoked
by its class&rsquo;s destructor (<code>~Vector_container()</code>).
</p>

<p>
Virtual function table (<code>vtbl</code>).
</p>

<p>
A function in a derived class overrides a virtual function
in a base class if that function has exactly the same name and type.
</p>

<p>
A function with a slightly different name or a slightly different type
may be intended to override or it may be intended to be a separate function.
</p>

<p>
Explicitly state that a function is meant to override:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">move</span>(<span class="org-type">Point</span> <span class="org-variable-name">to</span>) <span class="org-keyword">override</span>;
</pre>
</div>
</div>

<div id="outline-container-org3950cb4" class="outline-3">
<h3 id="org3950cb4"><span class="section-number-3">4.1.</span> Dynamic Casting</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Dynamic casting:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">if</span> (<span class="org-type">Smiley</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">dynamic_cast</span>&lt;<span class="org-type">Smiley</span>*&gt;(ps)) { <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span> }
</pre>
</div>
<p>
If the object pointed to by the argument of <code>dynamic_cast</code>
is not of the expected type or a class derived from the expected type,
<code>dynamic_cast</code> returns <code>nullptr</code>.
</p>

<p>
When a different type is unacceptable, we can simply <code>dynamic_cast</code> to a reference type.
If the object is not of the expected type, <code>bad_cast</code> is thrown:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Smiley</span> &amp;<span class="org-variable-name">r</span>{<span class="org-keyword">dynamic_cast</span>&lt;<span class="org-type">Smiley</span> &amp;&gt;(*ps)};
</pre>
</div>

<p>
Better resource handling: return <code>unique_ptr</code> rather than
a naked pointer and store <code>unique_ptrs</code> in the container:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">vector</span>&lt;<span class="org-type">unique_ptr</span>&lt;Shape&gt;&gt; <span class="org-variable-name">v</span>;
  v.push_back(<span class="org-type">unique_ptr</span>&lt;Shape&gt;{<span class="org-keyword">new</span> <span class="org-type">Circle</span>{p, r}});
</pre>
</div>

<p>
Now the object is owned by the <code>unique_ptr</code> which will delete the object
when it is no longer needed, that is, when its <code>unique_ptr</code> goes out of scope.
</p>
</div>
</div>

<div id="outline-container-org5f962b0" class="outline-3">
<h3 id="org5f962b0"><span class="section-number-3">4.2.</span> Copy and Move</h3>
<div class="outline-text-3" id="text-4-2">
<p>
By default, objects can be copied.
The default meaning of copy is memberwise copy: copy each member.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">complex</span> <span class="org-variable-name">z2</span>{z1}; <span class="org-comment-delimiter">// </span><span class="org-comment">copy initialization</span>
  <span class="org-type">complex</span> <span class="org-variable-name">z3</span>;
  z3 = z2;        <span class="org-comment-delimiter">// </span><span class="org-comment">copy assignment</span>
</pre>
</div>

<p>
Copy constructor and copy assignment:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector(<span class="org-keyword">const</span> <span class="org-type">Vector</span> &amp;<span class="org-variable-name">a</span>);            <span class="org-comment-delimiter">// </span><span class="org-comment">copy constructor</span>
  <span class="org-type">Vector</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Vector</span> &amp;<span class="org-variable-name">a</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">copy assignment</span>

  <span class="org-constant">Vector</span>::<span class="org-function-name">Vector</span>(<span class="org-keyword">const</span> <span class="org-type">Vector</span> &amp;<span class="org-variable-name">a</span>) : elem{<span class="org-keyword">new</span> <span class="org-type">double</span>[a.sz]}, sz{a.sz} {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = <span class="org-highlight-numbers-number">0</span>; i != sz; ++i)
      elem[i] = a.elem[i];
  }

  <span class="org-type">Vector</span> &amp;<span class="org-constant">Vector</span>::<span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Vector</span> &amp;<span class="org-variable-name">a</span>) {
    <span class="org-type">double</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">double</span>[a.sz];
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = <span class="org-highlight-numbers-number">0</span>; i != a.sz; ++i)
      p[i] = a.elem[i];
    <span class="org-keyword">delete</span>[] elem; <span class="org-comment-delimiter">// </span><span class="org-comment">delete old elements</span>
    elem = p;
    sz = a.sz;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
  }
</pre>
</div>

<p>
To avoid copying in returning value:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Vector</span> <span class="org-function-name">foo</span>(<span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span>) {
    <span class="org-type">Vector</span> <span class="org-variable-name">res</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-keyword">return</span> res;
  }

</pre>
</div>

<p>
Move constructor and move assignment should be implemented:
</p>
<div class="org-src-container">
<pre class="src src-c++">  Vector(<span class="org-type">Vector</span> &amp;&amp;<span class="org-variable-name">a</span>);            <span class="org-comment-delimiter">// </span><span class="org-comment">move constructor</span>
  <span class="org-type">Vector</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-type">Vector</span> &amp;&amp;<span class="org-variable-name">a</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">move assignment</span>

  <span class="org-constant">Vector</span>::<span class="org-function-name">Vector</span>(<span class="org-type">Vector</span> &amp;&amp;<span class="org-variable-name">a</span>)
      : elem{a.elem}, sz{a.sz} { <span class="org-comment-delimiter">// </span><span class="org-comment">"grab the elements" from a</span>
    a.elem = <span class="org-constant">nullptr</span>; a.sz = <span class="org-highlight-numbers-number">0</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">now a has no elements</span>
  }
</pre>
</div>

<p>
The <code>&amp;&amp;</code> means <i>rvalue</i> reference and is a reference to which we can bind an rvalue.
The word &ldquo;rvalue&rdquo; is intended to complement &ldquo;lvalue,&rdquo; which roughly means
&ldquo;something that can appear on the left-hand side of an assignment.&rdquo;
So an <b>rvalue</b> is – to a first approximation – <b>a value that you can&rsquo;t assign to</b>,
such as an integer returned by a function call.
Thus, an rvalue reference is a reference to something that nobody else can assign to,
so that we can safely &ldquo;steal&rdquo; its value.
</p>

<p>
A move operation is applied when an rvalue reference is used
as an initializer or as the right-hand side of an assignment.
</p>

<p>
Manually move with <code>std::move</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Vector</span> <span class="org-function-name">f</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    z = x;            <span class="org-comment-delimiter">// </span><span class="org-comment">we get a copy</span>
    y = <span class="org-constant">std</span>::move(x); <span class="org-comment-delimiter">// </span><span class="org-comment">we get a move</span>
    <span class="org-keyword">return</span> z;         <span class="org-comment-delimiter">// </span><span class="org-comment">we get a move</span>
  }
</pre>
</div>
</div>
</div>


<div id="outline-container-org7e9f2e2" class="outline-3">
<h3 id="org7e9f2e2"><span class="section-number-3">4.3.</span> Essential Operations</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">X</span> {
  <span class="org-keyword">public</span>:
    X(Sometype);             <span class="org-comment-delimiter">// </span><span class="org-comment">ordinary constructor: create an object</span>
    <span class="org-function-name">X</span>();                     <span class="org-comment-delimiter">// </span><span class="org-comment">default constructor</span>
    <span class="org-function-name">X</span>(<span class="org-keyword">const</span> <span class="org-type">X</span> &amp;);            <span class="org-comment-delimiter">// </span><span class="org-comment">copy constructor</span>
    <span class="org-function-name">X</span>(<span class="org-type">X</span> &amp;&amp;);                 <span class="org-comment-delimiter">// </span><span class="org-comment">move constructor</span>
    <span class="org-type">X</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">X</span> &amp;); <span class="org-comment-delimiter">// </span><span class="org-comment">copy assignment: clean up target and copy</span>
    <span class="org-type">X</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-type">X</span> &amp;&amp;);      <span class="org-comment-delimiter">// </span><span class="org-comment">move assignment: clean up target and move</span>
    ~<span class="org-function-name">X</span>();                    <span class="org-comment-delimiter">// </span><span class="org-comment">destructor: clean up</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  };
</pre>
</div>

<p>
Except for the ordinary constructor, these can be generated by compiler:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Y</span> {
  <span class="org-keyword">public</span>:
    Y(Sometype);
    <span class="org-function-name">Y</span>(<span class="org-keyword">const</span> <span class="org-type">Y</span> &amp;) = <span class="org-keyword">default</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">I really want the default copy constructor</span>
    <span class="org-function-name">Y</span>(<span class="org-type">Y</span> &amp;&amp;) = <span class="org-keyword">default</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">I really want the default copy constructor</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  };
</pre>
</div>

<p>
If you are explicit about some defaults,
other default definitions will not be generated.
</p>

<p>
Eliminate the default definitions of those two operations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Shape</span> {
  <span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">no copy operations</span>
    <span class="org-function-name">Shape</span>(<span class="org-keyword">const</span> <span class="org-type">Shape</span> &amp;) = <span class="org-keyword">delete</span>;
    <span class="org-type">Shape</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Shape</span> &amp;) = <span class="org-keyword">delete</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">no move operations</span>
    <span class="org-function-name">Shape</span>(<span class="org-type">Shape</span> &amp;&amp;) = <span class="org-keyword">delete</span>;
    <span class="org-type">Shape</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-type">Shape</span> &amp;&amp;) = <span class="org-keyword">delete</span>;
    ~<span class="org-function-name">Shape</span>();
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  };
</pre>
</div>

<p>
A constructor taking a single argument defines a conversion from its argument type,
but if only <code>explicit</code> conversion is allowed:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">class</span> <span class="org-type">Vector</span> {
  <span class="org-keyword">public</span>:
    <span class="org-keyword">explicit</span> <span class="org-function-name">Vector</span>(<span class="org-type">int</span> <span class="org-variable-name">s</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">no implicit conversion from int to Vector</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  };
</pre>
</div>

<p>
<i>C++ also offers a garbage collection interface
 so that you can plug in a garbage collector.</i>
</p>

<p>
In the C++ standard library, RAII (Resource Acquisition Is Initialization) is pervasive:
 for example, memory (string, vector, map, <code>unordered_map</code>, etc.),
 files (ifstream, ofstream, etc.), threads (thread), locks (<code>lock_guard</code>, <code>unique_lock</code>, etc.),
 and general objects (through <code>unique_ptr</code> and <code>shared_ptr</code>).
</p>
</div>
</div>
</div>

<div id="outline-container-orge658430" class="outline-2">
<h2 id="orge658430"><span class="section-number-2">5.</span> Templates</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
  <span class="org-keyword">class</span> <span class="org-type">Vector</span> {
  <span class="org-keyword">private</span>:
    <span class="org-type">T</span>* <span class="org-variable-name">elem</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  }
  <span class="org-constant">Vector</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">Vector</span>(<span class="org-type">int</span> <span class="org-variable-name">s</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
</pre>
</div>

<p>
Using <code>class</code> to introduce a type parameter is equivalent to using <code>typename</code>,
and in older code we often see <code>template&lt;class T&gt;</code> as the prefix.
</p>

<p>
The <code>&gt;&gt;</code> in <code>Vector&lt;list&lt;int&gt;&gt;</code> terminates the nested template arguments;
it is not a misplaced input operator.
It is not (as in C++98) necessary to place a space between the two &gt;s.
</p>

<p>
Provide <code>begin()</code> and <code>end()</code> to support <code>range-for</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
  <span class="org-type">T</span> *<span class="org-function-name">begin</span>(<span class="org-type">Vector</span>&lt;<span class="org-type">T</span>&gt; &amp;<span class="org-variable-name">x</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">pointer to first element or nullptr</span>
    <span class="org-keyword">return</span> x.size() ? &amp;x[<span class="org-highlight-numbers-number">0</span>] : <span class="org-constant">nullptr</span>;
  }
  <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
  <span class="org-type">T</span> *<span class="org-function-name">end</span>(<span class="org-type">Vector</span>&lt;<span class="org-type">T</span>&gt; &amp;<span class="org-variable-name">x</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">pointer to one-past-last element</span>
    <span class="org-keyword">return</span> begin(x) + x.size();
  }
  <span class="org-type">void</span> <span class="org-function-name">f2</span>(<span class="org-type">Vector</span>&lt;<span class="org-type">string</span>&gt; &amp;<span class="org-variable-name">vs</span>) {
    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> &amp;<span class="org-variable-name">s</span> : vs)
      cout &lt;&lt; s &lt;&lt; <span class="org-string">'\n'</span>;
  }
</pre>
</div>

<p>
Templates are a compile-time mechanism,
so their use incurs no run-time overhead compared to hand-crafted code.
</p>

<p>
A template can take value arguments:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-type">int</span> <span class="org-variable-name">N</span>&gt;
  <span class="org-keyword">struct</span> <span class="org-type">Buffer</span> {
    <span class="org-keyword">using</span> <span class="org-type">value_type</span> = T;
    <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-function-name">size</span>() { <span class="org-keyword">return</span> N; }
    T[N];
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  };
</pre>
</div>

<p>
The alias <code>value_type</code> and the <code>constexpr</code> function are provided
to allow users (read-only) access to the template arguments.
</p>

<p>
Can be used to create arbitrarily sized buffers on stack:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">Buffer</span>&lt;<span class="org-type">char</span>,<span class="org-highlight-numbers-number">1024</span>&gt; <span class="org-variable-name">glob</span>;
</pre>
</div>

<p>
Function object: objects that can be called like functions:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
  <span class="org-keyword">class</span> <span class="org-type">Less_than</span> {
    <span class="org-keyword">const</span> <span class="org-type">T</span> <span class="org-variable-name">val</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">value to compare against</span>
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Less_than</span>(<span class="org-keyword">const</span> <span class="org-type">T</span> &amp;<span class="org-variable-name">v</span>) : val(v) {}
    <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">()</span>(<span class="org-keyword">const</span> <span class="org-type">T</span> &amp;<span class="org-variable-name">x</span>) <span class="org-keyword">const</span> { <span class="org-keyword">return</span> x &lt; val; } <span class="org-comment-delimiter">// </span><span class="org-comment">call operator</span>
  };

  count(vec, <span class="org-type">Less_than</span>&lt;<span class="org-type">int</span>&gt;{x});
</pre>
</div>

<p>
Lambda expression:
</p>
<div class="org-src-container">
<pre class="src src-c++">  count(vec, [&amp;](<span class="org-type">int</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a &lt; x; });
</pre>
</div>

<p>
Capture nothing is <code>[ ]</code> , capture all local names used by reference is <code>[&amp;]</code> ,
 and capture all local names used by value is <code>[=]</code> .
</p>

<p>
Had we wanted to capture only x, we could have said so: <code>[&amp;x]</code> .
Had we wanted to give the generated object a copy of x,
we could have said so: <code>[=x]</code> .
</p>

<p>
Variadic templates:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span>() { } <span class="org-comment-delimiter">// </span><span class="org-comment">do nothing</span>
  <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span><span class="org-function-name">...</span> <span class="org-type">Tail</span>&gt;
  <span class="org-type">void</span> <span class="org-function-name">f</span>(<span class="org-type">T</span> <span class="org-variable-name">head</span>, <span class="org-type">Tail</span><span class="org-function-name">...</span> <span class="org-variable-name">tail</span>) {
    g(head);    <span class="org-comment-delimiter">// </span><span class="org-comment">do something to head</span>
    f(tail<span class="org-function-name">...</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">try again with tail</span>
  }
</pre>
</div>

<p>
Another example in chapter 11:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span><span class="org-function-name">...</span> <span class="org-type">Args</span>&gt;
  <span class="org-type">unique_ptr</span>&lt;<span class="org-type">T</span>&gt; <span class="org-function-name">make_unique</span>(<span class="org-type">Args</span> &amp;&amp;<span class="org-function-name">...</span> <span class="org-variable-name">args</span>) {
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span>&lt;<span class="org-type">T</span>&gt;{<span class="org-keyword">new</span> <span class="org-type">T</span>{<span class="org-constant">std</span>::forward&lt;<span class="org-type">Args</span>&gt;(args)<span class="org-function-name">...</span>}};
  }
</pre>
</div>

<p>
Aliases:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-comment-delimiter">// </span><span class="org-comment">in &lt;cstddef&gt;</span>
  <span class="org-keyword">using</span> <span class="org-type">size_t</span> = <span class="org-type">unsigned</span> <span class="org-type">int</span>;
</pre>
</div>

<p>
It is very common for a parameterized type to provide
an alias for types related to their template arguments.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
  <span class="org-keyword">class</span> <span class="org-type">Vector</span> {
  <span class="org-keyword">public</span>:
    <span class="org-keyword">using</span> <span class="org-type">value_type</span> = T;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  };
</pre>
</div>

<p>
In fact, every standard-library container provides
<code>value_type</code> as the name of its value type.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">C</span>&gt;
  <span class="org-keyword">using</span> <span class="org-type">Element_type</span> = <span class="org-keyword">typename</span> <span class="org-constant">C</span>::value_type;

  <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Container</span>&gt;
  <span class="org-type">void</span> <span class="org-function-name">algo</span>(<span class="org-type">Container</span> &amp;<span class="org-variable-name">c</span>) {
    <span class="org-type">Vector</span>&lt;<span class="org-type">Element_type</span>&lt;<span class="org-type">Container</span>&gt;&gt; <span class="org-variable-name">vec</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  }
</pre>
</div>

<p>
A function template argument needs to be explicitly mentioned
only if it cannot be deduced or if there is no default:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Target</span> = string, <span class="org-keyword">typename</span> <span class="org-type">Source</span> = string&gt;
  <span class="org-type">Target</span> <span class="org-function-name">to</span>(<span class="org-type">Source</span> <span class="org-variable-name">arg</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  }
  <span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-keyword">auto</span> <span class="org-variable-name">x1</span> = to&lt;<span class="org-type">string</span>, <span class="org-type">double</span>&gt;(<span class="org-highlight-numbers-number">1.2</span>);
    <span class="org-keyword">auto</span> <span class="org-variable-name">x2</span> = to&lt;<span class="org-type">string</span>&gt;(<span class="org-highlight-numbers-number">1.2</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">Source is deduced to double</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">x3</span> = to&lt;&gt;(<span class="org-highlight-numbers-number">1.2</span>);
    <span class="org-keyword">auto</span> <span class="org-variable-name">x4</span> = to(<span class="org-highlight-numbers-number">1.2</span>);
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaeded69" class="outline-2">
<h2 id="orgaeded69"><span class="section-number-2">6.</span> Library Overview</h2>
<div class="outline-text-2" id="text-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Selected Standard Library Headers</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">header</th>
<th scope="col" class="org-left">declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&lt;string&gt;</td>
<td class="org-left">string, basic_string</td>
</tr>

<tr>
<td class="org-left">&lt;regex&gt;</td>
<td class="org-left">regex, smatch</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;fstream&gt;</td>
<td class="org-left">fstream, ifstream, ofstream</td>
</tr>

<tr>
<td class="org-left">&lt;iostream&gt;</td>
<td class="org-left">istream, ostream, cin, cout</td>
</tr>

<tr>
<td class="org-left">&lt;sstream&gt;</td>
<td class="org-left">istrstream, ostrstream</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;array&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">&lt;vector&gt;</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">&lt;set&gt;</td>
<td class="org-left">set, multiset</td>
</tr>

<tr>
<td class="org-left">&lt;map&gt;</td>
<td class="org-left">map, multimap</td>
</tr>

<tr>
<td class="org-left">&lt;unordered_map&gt;</td>
<td class="org-left">unordered_map, unordered_multimap</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;algorithm&gt;</td>
<td class="org-left">copy(), find(), sort()</td>
</tr>

<tr>
<td class="org-left">&lt;random&gt;</td>
<td class="org-left">default_random_engine, normal_distribution</td>
</tr>

<tr>
<td class="org-left">&lt;memory&gt;</td>
<td class="org-left">unique_ptr, shared_ptr, allocator</td>
</tr>

<tr>
<td class="org-left">&lt;utility&gt;</td>
<td class="org-left">move(), swap(), pair</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;cmath&gt;</td>
<td class="org-left">sqrt(), pow()</td>
</tr>

<tr>
<td class="org-left">&lt;complex&gt;</td>
<td class="org-left">complex, sqrt(), pow()</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;future&gt;</td>
<td class="org-left">future, promise</td>
</tr>

<tr>
<td class="org-left">&lt;thread&gt;</td>
<td class="org-left">thread</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;forward_list&gt;</td>
<td class="org-left">forward_list</td>
</tr>

<tr>
<td class="org-left">&lt;stdexcept&gt;</td>
<td class="org-left">length_error, out_of_range, runtime_error</td>
</tr>

<tr>
<td class="org-left">&lt;chrono&gt;</td>
<td class="org-left">duration, time_point</td>
</tr>

<tr>
<td class="org-left">&lt;ios&gt;</td>
<td class="org-left">hex,dec,scientific,fixed,defaultfloat</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgee97bdb" class="outline-2">
<h2 id="orgee97bdb"><span class="section-number-2">7.</span> Strings and Regular Expressions</h2>
<div class="outline-text-2" id="text-7">
<p>
A string is mutable: <code>=</code>, <code>+=</code>, <code>[]</code>.
</p>

<p>
<code>.size()</code>, <code>.insert()</code>, <code>.erase()</code>, <code>.find()</code> (<code>string::npos</code>),
<code>.substr()</code>, <code>.replace()</code>, <code>.c_str()</code> (read-only).
</p>

<p>
<b>short-string optimization</b>: short string values are kept in the string object itself
and only longer strings are placed on free store.
</p>

<p>
<code>string</code> is really an alias for a general template <code>basic_string</code>
with the character type <code>char</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">using</span> <span class="org-type">string</span> = <span class="org-type">basic_string</span>&lt;<span class="org-type">char</span>&gt;
</pre>
</div>

<p>
<code>wstring</code>, <code>u16string</code>, <code>u32string</code>.
</p>
</div>

<div id="outline-container-org27deb10" class="outline-3">
<h3 id="org27deb10"><span class="section-number-3">7.1.</span> Regular Expressions</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Pattern:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">regex</span> <span class="org-function-name">pat</span> (R"<span class="org-string">(\w{2}\s&#8727;\d{5}(&#8722;\d{4})?)</span>");
</pre>
</div>

<p>
<code>regex_match()</code>, <code>regex_search()</code>, <code>regex_replace()</code>, <code>regex_iterator</code>, <code>regex_token_iterator</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">int</span> <span class="org-variable-name">lineno</span> = <span class="org-highlight-numbers-number">0</span>;
  <span class="org-keyword">for</span> (<span class="org-type">string</span> <span class="org-variable-name">line</span>; getline(cin, line);) {
    ++lineno;
    <span class="org-type">smatch</span> <span class="org-variable-name">matches</span>;
    <span class="org-keyword">if</span> (regex_search(line, matches, pat))
      cout &lt;&lt; lineno &lt;&lt; <span class="org-string">": "</span> &lt;&lt; matches[<span class="org-highlight-numbers-number">0</span>] &lt;&lt; <span class="org-string">'\n'</span>;
  }
</pre>
</div>

<p>
An smatch is a vector of sub-matches of type string.
The first element, here <code>matches[0]</code>, is the complete match.
</p>

<p>
Sub-match:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">if</span> (<span class="org-highlight-numbers-number">1</span> &lt; matches.size() &amp;&amp; matches[<span class="org-highlight-numbers-number">1</span>].matched)
    cout &lt;&lt; <span class="org-string">"\t: "</span> &lt;&lt; matches[<span class="org-highlight-numbers-number">1</span>] &lt;&lt; <span class="org-string">'\n'</span>;
</pre>
</div>

<p>
Regular expressions are compiled into state machines for efficient execution.
</p>

<p>
Character classes and abbreviations (skipped here).
</p>

<p>
Iterator:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">string</span> <span class="org-variable-name">input</span> = <span class="org-string">"aa as; asd ++e&#710;asdf asdfg"</span>;
  <span class="org-type">regex</span> <span class="org-variable-name">pat</span>{R"<span class="org-string">(\s+(\w+))</span>"};
  <span class="org-keyword">for</span> (<span class="org-type">sregex_iterator</span> <span class="org-function-name">p</span>(input.begin(), input.end(), pat);
       p != sregex_iterator{}; ++p)
    cout &lt;&lt; (*p)[<span class="org-highlight-numbers-number">1</span>] &lt;&lt; <span class="org-string">'\n'</span>;
</pre>
</div>

<p>
Return strings by value (rely on move semantics).
</p>

<p>
Use a string_stream or a generic value extraction function (such as <code>to&lt;X&gt;</code>)
for numeric conversion of strings.
</p>
</div>
</div>
</div>

<div id="outline-container-org7fd2dbe" class="outline-2">
<h2 id="org7fd2dbe"><span class="section-number-2">8.</span> I/O Streams</h2>
<div class="outline-text-2" id="text-8">
<p>
By default, <code>&gt;&gt;</code> skips initial whitespace.
</p>

<p>
By default, a whitespace character, such as a space or a newline, terminates the read.
You can read a whole line (including the terminating newline character) using the <code>getline()</code> function.
</p>
<div class="org-src-container">
<pre class="src src-c++">getline(cin,str);
</pre>
</div>

<p>
I/O state:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">while</span> (cin &gt;&gt; i)
    res.push_back(i);

  <span class="org-keyword">if</span> (cin.eof()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (cin.fail()) { <span class="org-comment-delimiter">// </span><span class="org-comment">a potentially recoverable error</span>
    cin.clear();           <span class="org-comment-delimiter">// </span><span class="org-comment">reset the state to good()</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">if fail again</span>
    cin.setstate(<span class="org-constant">ios_base</span>::failbit); <span class="org-comment-delimiter">// </span><span class="org-comment">add fail() to cin's state</span>
  }
</pre>
</div>

<p>
Custom <code>&lt;&lt;</code> and <code>&gt;&gt;</code> :
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">ostream</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">&lt;&lt;</span>(<span class="org-type">ostream</span> &amp;<span class="org-variable-name">os</span>, <span class="org-keyword">const</span> <span class="org-type">Entry</span> &amp;<span class="org-variable-name">e</span>) {
    <span class="org-keyword">return</span> os &lt;&lt; <span class="org-string">"{\""</span> &lt;&lt; e.name &lt;&lt; <span class="org-string">"\", "</span> &lt;&lt; e.number &lt;&lt; <span class="org-string">"}"</span>;
  }

  <span class="org-type">istream</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name">&gt;&gt;</span>(<span class="org-type">istream</span> &amp;<span class="org-variable-name">is</span>, <span class="org-type">Entry</span> &amp;<span class="org-variable-name">e</span>) {
    <span class="org-type">char</span> <span class="org-variable-name">c</span>, <span class="org-variable-name">c2</span>;
    <span class="org-keyword">if</span> (is &gt;&gt; c &amp;&amp; c == <span class="org-string">'{'</span> &amp;&amp; is &gt;&gt; c2 &amp;&amp; c2 == <span class="org-string">'"'</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">start with a {"</span>
      <span class="org-type">string</span> <span class="org-variable-name">name</span>;                                      <span class="org-comment-delimiter">// </span><span class="org-comment">read a string name</span>
      <span class="org-keyword">while</span> (is.get(c) &amp;&amp; c != <span class="org-string">'"'</span>)                     <span class="org-comment-delimiter">// </span><span class="org-comment">end with "</span>
        name += c;
      <span class="org-keyword">if</span> (is &gt;&gt; c &amp;&amp; c == <span class="org-string">','</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">seperated by ,</span>
        <span class="org-type">int</span> <span class="org-variable-name">number</span> = <span class="org-highlight-numbers-number">0</span>;
        <span class="org-keyword">if</span> (is &gt;&gt; number &gt;&gt; c &amp;&amp; c == <span class="org-string">'}'</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">read the number and a }</span>
          e = {name, number};
          <span class="org-keyword">return</span> is;
        }
      }
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">oh no</span>
    is.setstate(<span class="org-constant">ios_base</span>::failbit);
    <span class="org-keyword">return</span> is;
  }
</pre>
</div>

<p>
Formatting:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span><span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">  #include</span><span class="org-string">&lt;ios&gt;</span>
  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

  <span class="org-type">int</span> <span class="org-function-name">main</span>(){
    cout &lt;&lt; <span class="org-highlight-numbers-number">1234</span> &lt;&lt; <span class="org-string">','</span>
         &lt;&lt; hex &lt;&lt; <span class="org-highlight-numbers-number">1234</span> &lt;&lt; <span class="org-string">','</span>
         &lt;&lt; oct &lt;&lt; <span class="org-highlight-numbers-number">1234</span> &lt;&lt; <span class="org-string">'\n'</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">1234,4d2,2322</span>
    <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">d</span> = <span class="org-highlight-numbers-number">123.456</span>;
    cout &lt;&lt; d &lt;&lt; <span class="org-string">"; "</span>
         &lt;&lt; scientific &lt;&lt; d &lt;&lt; <span class="org-string">"; "</span>
         &lt;&lt; fixed &lt;&lt; d &lt;&lt; <span class="org-string">"; "</span>
         &lt;&lt; defaultfloat &lt;&lt; d &lt;&lt; <span class="org-string">'\n'</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">123.456; 1.234560e+02; 123.456000; 123.456</span>
    cout.precision(<span class="org-highlight-numbers-number">2</span>);
    cout &lt;&lt; fixed &lt;&lt; d &lt;&lt; <span class="org-string">'\n'</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">123.46</span>
  }
</pre>
</div>

<p>
<code>precision()</code> affects <code>defaultfloat</code>, <code>scientific</code>, <code>fixed</code>.
</p>

<p>
<code>#include &lt;iomanip&gt;</code> when using standard manipulators taking arguments.
</p>

<p>
Test files for reading and writing:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">ofstream</span> <span class="org-variable-name">ofs</span>(<span class="org-string">"target"</span>);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ofs) error(<span class="org-string">"couldn't open 'target' for writing"</span>);
  <span class="org-type">ifstream</span> <span class="org-variable-name">ifs</span>(<span class="org-string">"source"</span>);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ifs) error(<span class="org-string">"couldn't open 'source' for reading"</span>);
</pre>
</div>

<p>
<code>&lt;sstream&gt;</code> : <code>istringstream</code>,  <code>ostringstream</code>, <code>stringstream</code>.
</p>

<p>
The result from an istringstream can be read using <code>str()</code>.
</p>

<p>
Use <code>stringstream</code> for in-memory formatting.
</p>
</div>
</div>

<div id="outline-container-org3a4d79b" class="outline-2">
<h2 id="org3a4d79b"><span class="section-number-2">9.</span> Containers</h2>
<div class="outline-text-2" id="text-9">
<p>
typical implementation of vector:
</p>
<ul class="org-ul">
<li>elem : a handle holding pointers to the first element</li>
<li>space : one-past-the-last element</li>
<li>last : one-past-the-last allocated space</li>
<li>alloc : allocator from which can acquire memory for elements</li>
</ul>

<p>
Initilize:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">v1</span> = {<span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">3</span>, <span class="org-highlight-numbers-number">4</span>}; <span class="org-comment-delimiter">// </span><span class="org-comment">size is 4</span>
  <span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">v2</span>;             <span class="org-comment-delimiter">// </span><span class="org-comment">size is 0</span>
  <span class="org-type">vector</span>&lt;<span class="org-type">Shape</span>*&gt; <span class="org-variable-name">v3</span>(<span class="org-highlight-numbers-number">23</span>);         <span class="org-comment-delimiter">// </span><span class="org-comment">size is 23; initial element value: nullptr</span>
  <span class="org-type">vector</span>&lt;<span class="org-type">double</span>&gt; <span class="org-variable-name">v4</span>(<span class="org-highlight-numbers-number">32</span>, <span class="org-highlight-numbers-number">9.9</span>);    <span class="org-comment-delimiter">// </span><span class="org-comment">size is 32; initial element value: 9.9</span>
</pre>
</div>

<p>
A vector can be copied in assignments and initializations:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">vector</span>&lt;Entry&gt; <span class="org-variable-name">book2</span> = phone_book;
</pre>
</div>

<p>
When you insert a new element, its value is copied into the container.
</p>

<p>
The <code>at()</code> operation throws an exception of type <code>out_of_range</code>
if its argument is out of the vector&rsquo;s range.
</p>

<p>
<code>list</code> : doubly-linked list.
</p>

<p>
<code>map</code> : a search tree (a red-black tree).
</p>

<p>
If a key isn’t found with <code>[]</code>, it is inserted into the <code>map</code> with a default value for its value.
</p>

<p>
<code>nordered_map</code>.
The standard-library provides a default hash function for strings
as well as for other built-in and standard-library types.
If necessary, you can provide your own.
</p>

<p>
A hash function is often provided as a function object:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">struct</span> <span class="org-type">Record</span> {
    <span class="org-type">string</span> <span class="org-variable-name">name</span>;
    <span class="org-type">int</span> <span class="org-variable-name">product_code</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  };
  <span class="org-comment-delimiter">// </span><span class="org-comment">a hash function for Record</span>
  <span class="org-keyword">struct</span> <span class="org-type">Rhash</span> {
    <span class="org-type">size_t</span> <span class="org-keyword">operator</span><span class="org-function-name">()</span>(<span class="org-keyword">const</span> <span class="org-type">Record</span> &amp;<span class="org-variable-name">r</span>) <span class="org-keyword">const</span> {
      <span class="org-keyword">return</span> hash&lt;<span class="org-type">string</span>&gt;()(r.name) ^ hash&lt;<span class="org-type">int</span>&gt;()(r.product_code);
    }
  };
  <span class="org-comment-delimiter">// </span><span class="org-comment">set of Recoreds using Rhash for lookup</span>
  <span class="org-type">unordered_set</span>&lt;<span class="org-type">Record</span>, <span class="org-type">Rhash</span>&gt; <span class="org-variable-name">my_set</span>;
</pre>
</div>

<p>
Creaing a new hash function by combining existing hash functions
using exclusive or (^) is simple and often very effective.
</p>

<ul class="org-ul">
<li>vector&lt;T&gt;, list&lt;T&gt;, forward_list&lt;T&gt;</li>
<li>map&lt;K,V&gt;, multimap&lt;K,V&gt;, unordered_map&lt;K,V&gt;, unordered_multimap&lt;K,V&gt;</li>
<li>set&lt;T&gt;, multiset&lt;T&gt;, unordered_set&lt;T&gt; unordered_multiset&lt;T&gt;</li>
<li>deque&lt;T&gt;, queue&lt;T&gt;, stack&lt;T&gt;, priority_queue&lt;T&gt;</li>
<li>fixed-size array <code>array&lt;T,N&gt;</code>, bitset&lt;N&gt;</li>
</ul>

<p>
Please note that a vector is usually more efficient than a list
for short sequences of small elements (even for insert() and erase()).
</p>

<p>
Use <code>forward_list</code> for sequences that are usually empty.
</p>

<p>
When it comes to performance, don’t trust your intuition: measure.
</p>

<p>
Pass a container by reference and return a container by value.
</p>
</div>
</div>

<div id="outline-container-org553a6c0" class="outline-2">
<h2 id="org553a6c0"><span class="section-number-2">10.</span> Algorithms</h2>
<div class="outline-text-2" id="text-10">
<div class="org-src-container">
<pre class="src src-c++">  sort(vec.begin(), vec.end());
  unique_copy(vec.begin(), vec.end(), lst.begin());
  unique_copy(vec.begin(), vec.end(), back_inserter(lst));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++">   <span class="org-keyword">if</span> (find(s.begin(), s.end(), c) != s.end())
     <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span>;
</pre>
</div>

<p>
each container knows its iterator types and makes them available
under the conventional names <code>iterator</code> and <code>const_iterator</code>.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">C</span>, <span class="org-keyword">typename</span> <span class="org-type">V</span>&gt;
  <span class="org-type">vector</span>&lt;<span class="org-keyword">typename</span> <span class="org-constant">C</span>::<span class="org-type">iterator</span>&gt; <span class="org-function-name">find_all</span>(<span class="org-type">C</span> &amp;<span class="org-variable-name">c</span>, <span class="org-type">V</span> <span class="org-variable-name">v</span>) {
</pre>
</div>

<p>
The typename is needed to inform the compiler that
C&rsquo;s iterator is supposed to be a type and not a value of some type.
</p>

<p>
With aliases:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-keyword">using</span> <span class="org-type">Iterator</span> = <span class="org-keyword">typename</span> <span class="org-constant">T</span>::iterator;

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">C</span>, <span class="org-keyword">typename</span> <span class="org-type">V</span>&gt;
<span class="org-type">vector</span>&lt;<span class="org-type">Iterator</span>&lt;<span class="org-type">C</span>&gt;&gt; <span class="org-function-name">find_all</span>(<span class="org-type">C</span>&amp; <span class="org-variable-name">c</span>, <span class="org-type">V</span> <span class="org-variable-name">v</span>) {
</pre>
</div>

<p>
Stream iterator:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">ostream_iterator</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">oo</span>{cout}; <span class="org-comment-delimiter">// </span><span class="org-comment">write strings to cout</span>
    *oo = <span class="org-string">"Hello, "</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">meaning cout&lt;&lt;"Hello, "</span>
    ++oo;
    *oo = <span class="org-string">"world!\n"</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">meaning cout&lt;&lt;"world!\n"</span>
    <span class="org-type">istream_iterator</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">ii</span>{cin};
    <span class="org-type">istream_iterator</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">eos</span>{}; <span class="org-comment-delimiter">// </span><span class="org-comment">indicate the end of input</span>
  }
</pre>
</div>

<p>
Manipulate files:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">int</span> <span class="org-function-name">unique_copy</span>(<span class="org-type">string</span> <span class="org-variable-name">from</span>, <span class="org-type">string</span> <span class="org-variable-name">to</span>) {
    <span class="org-type">ifstream</span> <span class="org-variable-name">is</span>{from};
    <span class="org-type">ofstream</span> <span class="org-variable-name">os</span>{to};
    <span class="org-type">set</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">b</span>{<span class="org-type">istream_iterator</span>&lt;<span class="org-type">string</span>&gt;{is}, <span class="org-type">istream_iterator</span>&lt;<span class="org-type">string</span>&gt;{}};
    copy(b.begin(), b.end(), <span class="org-type">ostream_iterator</span>&lt;<span class="org-type">string</span>&gt;{os, <span class="org-string">"\n"</span>});
    <span class="org-keyword">return</span> <span class="org-negation-char">!</span>is.eof() || <span class="org-negation-char">!</span>os;
  }
</pre>
</div>

<p>
Predictors:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">struct</span> <span class="org-type">Greater_than</span> {
    <span class="org-type">int</span> <span class="org-variable-name">val</span>;
    <span class="org-function-name">Greater_than</span>(<span class="org-type">int</span> <span class="org-variable-name">v</span>) : val{v} {}
    <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">()</span>(<span class="org-keyword">const</span> <span class="org-type">pair</span>&lt;<span class="org-type">string</span>, <span class="org-type">int</span>&gt; &amp;<span class="org-variable-name">r</span>) { <span class="org-keyword">return</span> r.second &gt; val; }
  };
  <span class="org-comment-delimiter">// </span><span class="org-comment">use as</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">p</span> = find_if(m.begin(), m.end(), Greater_than{<span class="org-highlight-numbers-number">42</span>});
  <span class="org-comment-delimiter">// </span><span class="org-comment">or lambda</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">p</span> = find_if(m.begin(), m.end(), [](<span class="org-keyword">const</span> <span class="org-type">pair</span>&lt;<span class="org-type">string</span>,<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">r</span>) { <span class="org-keyword">return</span> r.second&gt;<span class="org-highlight-numbers-number">42</span>; });
</pre>
</div>

<p>
A predicate must not modify its argument.
</p>

<p>
Functions in <code>&lt;algorithm&gt;</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  p = find(b, e, x);
  p = find_if(b, e, f);
  n = count(b, e, x);
  n = count_if(b, e, f);
  replace(b, e, v, v2);
  replace_if(b, e, f, v2);
  p = copy(b, e, out); <span class="org-comment-delimiter">// </span><span class="org-comment">from [b:e) to [out:p)</span>
  p = copy_if(b, e, out, f);
  p = move(b, e, out);
  p = unique_copy(b, e, out);
  sort(b, e);
  sort(b, e, f);                   <span class="org-comment-delimiter">// </span><span class="org-comment">Sort elements of [b:e) using f</span>
  (p1, p2) = equal_range(b, e, v); <span class="org-comment-delimiter">// </span><span class="org-comment">[p1:p2) is the subsequence with the value v</span>
  p = merge(b, e, b2, e2, out);
</pre>
</div>

<p>
Some algorithms, such as <code>replace()</code> and <code>sort()</code>, modify element values,
But <b>no algorithm add or subtract elements</b> of a container.
</p>

<p>
If you want to add elements, you need something,
such as an <code>back_inserter</code> that knows about the container.
</p>
</div>
</div>

<div id="outline-container-orgdfc8358" class="outline-2">
<h2 id="orgdfc8358"><span class="section-number-2">11.</span> Utilities</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org5d99a47" class="outline-3">
<h3 id="org5d99a47"><span class="section-number-3">11.1.</span> Smart Pointers</h3>
<div class="outline-text-3" id="text-11-1">
<p>
In <code>&lt;memory&gt;</code>, the stan- dard library provides two 
smart pointers to help manage objects on the free store:
</p>
<ol class="org-ol">
<li><code>unique_ptr</code> to represent unique ownership</li>
<li><code>shared_ptr</code> to represent shared ownership</li>
</ol>

<p>
The <code>shared_ptr</code> is similar to <code>unique_ptr</code> except that
shared_ptrs are <b>copied rather than moved</b>.
</p>

<p>
The shared_ptrs for an object share ownership of an object and
that object is destroyed when the last of its shared_ptrs is destroyed.
</p>

<p>
the standard library (in <code>&lt;memory&gt;</code>) provides a function <code>make_shared()</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">shared_ptr</span>&lt;S&gt; <span class="org-variable-name">p1</span>{<span class="org-keyword">new</span> <span class="org-type">S</span>{<span class="org-highlight-numbers-number">1</span>, <span class="org-string">"Ankh Morpork"</span>, <span class="org-highlight-numbers-number">4.65</span>}};
  <span class="org-keyword">auto</span> <span class="org-variable-name">p2</span> = make_shared&lt;S&gt;(<span class="org-highlight-numbers-number">2</span>, <span class="org-string">"Oz"</span>, <span class="org-highlight-numbers-number">7.62</span>);
</pre>
</div>

<p>
Use <code>unique_ptr</code> to refer to objects of polymorphic type.
Use <code>shared_ptr</code> to refer to shared objects.
</p>
</div>
</div>

<div id="outline-container-org7ab8b8d" class="outline-3">
<h3 id="org7ab8b8d"><span class="section-number-3">11.2.</span> Specialized Containers</h3>
<div class="outline-text-3" id="text-11-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Almost Conainers</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Container</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T[N]</td>
<td class="org-left">Built-in array</td>
</tr>

<tr>
<td class="org-left">array&lt;T,N&gt;</td>
<td class="org-left">Like the built-in array, but <b>with most problems solved</b></td>
</tr>

<tr>
<td class="org-left">bitset&lt;N&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">vector&lt;bool&gt;</td>
<td class="org-left">A sequence of bits <b>compactly</b> stored in a specialization of vector</td>
</tr>

<tr>
<td class="org-left">pair&lt;T,U&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">tuple&lt;T&#x2026;&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">basic_string&lt;C&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">valarray&lt;T&gt;</td>
<td class="org-left">An array of numeric values of type T; provides numeric operations</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgc1c24d9" class="outline-4">
<h4 id="orgc1c24d9"><span class="section-number-4">11.2.1.</span> array</h4>
<div class="outline-text-4" id="text-11-2-1">
<p>
An array, defined in <code>&lt;array&gt;</code>, is a fixed-size sequence of elements of a given type
where <b>the number of elements is specified at compile time</b>.
</p>

<p>
Thus, an array can be allocated with its elements on the stack,
in an object, or in static storage.
</p>

<p>
There is no overhead (time or space) involved in using an array
compared to using a built-in array.
</p>

<p>
An array knows its size, can be copied (using = or initialization),
and saves one from surprising nasty conversions to pointers.
</p>

<p>
An array does not &ldquo;handle to elements.&rdquo;
</p>

<p>
The element count is not optional:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">array</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ax</span> = {<span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">3</span>};
</pre>
</div>

<p>
an array can be explicitly passed to a C-style function that expects a pointer:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span>(<span class="org-type">int</span>&#8727; p, <span class="org-type">int</span> <span class="org-variable-name">sz</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">C-style interface</span>
  <span class="org-type">void</span> <span class="org-function-name">g</span>() {
    <span class="org-type">array</span>&lt;<span class="org-type">int</span>, <span class="org-highlight-numbers-number">10</span>&gt; <span class="org-variable-name">a</span>;
    f(a, a.size());                         <span class="org-comment-delimiter">// </span><span class="org-comment">error: no conversion</span>
    f(&amp;a[<span class="org-highlight-numbers-number">0</span>], a.size());                     <span class="org-comment-delimiter">// </span><span class="org-comment">C-style use</span>
    f(a.data(), a.size());                  <span class="org-comment-delimiter">// </span><span class="org-comment">C-style use</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">p</span> = find(a.begin(), a.end(), <span class="org-highlight-numbers-number">777</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">C++/STL-style use</span>
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-org7e3111b" class="outline-4">
<h4 id="org7e3111b"><span class="section-number-4">11.2.2.</span> bitset</h4>
<div class="outline-text-4" id="text-11-2-2">
<p>
A <code>bitset</code> can be initialized with an integer or a string:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">bitset</span>&lt;<span class="org-highlight-numbers-number">9</span>&gt; <span class="org-variable-name">bs1</span>{<span class="org-string">"110001111"</span>};
  <span class="org-type">bitset</span>&lt;<span class="org-highlight-numbers-number">9</span>&gt; <span class="org-variable-name">bs2</span>{<span class="org-highlight-numbers-number">399</span>};
  <span class="org-type">bitset</span>&lt;<span class="org-highlight-numbers-number">9</span>&gt; <span class="org-variable-name">bs3</span> =  &#771;bs1;
  <span class="org-type">bitset</span>&lt;<span class="org-highlight-numbers-number">9</span>&gt; <span class="org-variable-name">bs4</span> = bs1 &amp; bs3;
  <span class="org-type">bitset</span>&lt;<span class="org-highlight-numbers-number">9</span>&gt; <span class="org-variable-name">bs5</span> = bs1 &lt;&lt; <span class="org-highlight-numbers-number">2</span>;
</pre>
</div>

<p>
<code>to_ullong()</code> and <code>to_string()</code> provide the inverse operations to the constructors.
</p>
</div>
</div>

<div id="outline-container-org1f39295" class="outline-4">
<h4 id="org1f39295"><span class="section-number-4">11.2.3.</span> pair and tuple</h4>
<div class="outline-text-4" id="text-11-2-3">
<p>
The make_pair() / make_tuple() function makes it easy to create
a pair / tuple without explicitly mentioning its type.
</p>

<p>
Elements of tuple can be accessed by <code>get&lt;0&gt;(t), get&lt;1&gt;(t), get&lt;2&gt;(t)</code>.
</p>
</div>
</div>

<div id="outline-container-org48f460e" class="outline-4">
<h4 id="org48f460e"><span class="section-number-4">11.2.4.</span> Time</h4>
<div class="outline-text-4" id="text-11-2-4">
<p>
The standard-library facilities for dealing with time
are found in the subnamespace <code>std::chrono</code> in <code>&lt;chrono&gt;</code>.
</p>

<p>
Timing something:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">t0</span> = <span class="org-constant">high_resolution_clock</span>::now();
  do_work();
  <span class="org-keyword">auto</span> <span class="org-variable-name">t1</span> = <span class="org-constant">high_resolution_clock</span>::now();
  cout &lt;&lt; duration_cast&lt;milliseconds&gt;(t1&#8722;t0).count() &lt;&lt; <span class="org-string">"msec\n"</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgff32228" class="outline-4">
<h4 id="orgff32228"><span class="section-number-4">11.2.5.</span> Function</h4>
<div class="outline-text-4" id="text-11-2-5">
<p>
A function adaptor takes a function as argument and returns a function object
that can be used to invoke the original function.
</p>

<p>
The standard library provides <code>bind()</code> and <code>mem_fn()</code> adaptors to do argument binding,
also called <i>Currying</i> or <i>partial evaluation</i>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span><span class="org-string">&lt;functional&gt;</span>
  <span class="org-type">void</span> <span class="org-function-name">f</span>(<span class="org-type">int</span>, <span class="org-keyword">const</span> <span class="org-type">string</span> &amp;);
  <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = bind(f, <span class="org-highlight-numbers-number">2</span>, <span class="org-constant">placeholders</span>::<span class="org-constant">_1</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">bind f()&#8217;s first argument to 2</span>
  f(<span class="org-highlight-numbers-number">2</span>, <span class="org-string">"hello"</span>);
  g(<span class="org-string">"hello"</span>);
</pre>
</div>

<p>
Use <code>mem_fn()</code> to create function objects that can invoke a member function
when called using the traditional function call notation.
</p>
<div class="org-src-container">
<pre class="src src-c++">  p&#8722;&gt; draw();
  <span class="org-keyword">auto</span> <span class="org-variable-name">draw</span> = mem_fn(&amp;<span class="org-constant">Shape</span>::draw);
  draw(p);

  for_each(v.begin(), v.end(), mem_fn(&amp;<span class="org-constant">Shape</span>::draw));
</pre>
</div>

<p>
Often, a lambda is an alternative to using <code>bind()</code> or <code>mem_fn()</code>.
</p>

<p>
A <code>function</code> is specified with a specific return type and a specific argument type:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">int</span> <span class="org-function-name">f1</span>(<span class="org-type">double</span>);
  <span class="org-type">function</span>&lt;<span class="org-type">int</span>(<span class="org-type">double</span>)&gt; <span class="org-variable-name">fct</span>{f1}; <span class="org-comment-delimiter">// </span><span class="org-comment">initialize to f1</span>

  <span class="org-type">void</span> <span class="org-function-name">user</span>() {
    fct = [](<span class="org-type">double</span> <span class="org-variable-name">d</span>) { <span class="org-keyword">return</span> round(d); }; <span class="org-comment-delimiter">// </span><span class="org-comment">assign lambda to fct</span>
    fct = f1;                                <span class="org-comment-delimiter">// </span><span class="org-comment">assign function to fct</span>
  }
</pre>
</div>

<p>
Use function when you need to store something that can be called.
</p>

<p>
A type function is a function that is evaluated at compile-time
given a type as its argument or returning a type.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">  #include</span> <span class="org-string">&lt;limits&gt;</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">float</span> <span class="org-variable-name">min</span> = <span class="org-constant">numeric_limits</span>&lt;<span class="org-type">float</span>&gt;::min(); <span class="org-comment-delimiter">// </span><span class="org-comment">smallest positive float</span>
</pre>
</div>

<p>
Metaprogramming or (when templates are involved) template metaprogramming.
</p>

<p>
<code>iterator_trait</code>, tag dispatch, type predicates.
</p>

<p>
<code>&lt;type_traits&gt;</code> : is_arithmetic, is_class, is_pod, is_literal_type,
has_virtual_destructor, and is_base_of.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org16c5a7f" class="outline-2">
<h2 id="org16c5a7f"><span class="section-number-2">12.</span> Numerics</h2>
<div class="outline-text-2" id="text-12">
<p>
<code>&lt;math&gt;</code> for float, double, long double :
abs(x), ceil(x), floor(x), sqrt(x), cos(x), sin(x),
tan(x), acos(x), asin(x), sinh(x), cosh(x), tanh(x),
exp(x), log(x).
</p>

<p>
The versions for <code>complex</code> are found in <code>&lt;complex&gt;</code>.
</p>

<p>
Errors are reported by setting errno from <code>&lt;cerrno&gt;</code> to <code>EDOM</code>
for a domain error and to <code>ERANGE</code> for a range error:
</p>
<div class="org-src-container">
<pre class="src src-c++">  errno = <span class="org-highlight-numbers-number">0</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">clear old error state</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-keyword">if</span> (errno == <span class="org-constant">EDOM</span>) cerr &lt;&lt; <span class="org-string">"domain error"</span>;
  <span class="org-keyword">if</span> (errno == <span class="org-constant">ERANGE</span>) cerr &lt;&lt; <span class="org-string">"range error"</span>;
</pre>
</div>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Numerical Algorithms in <code>&lt;numeric&gt;</code></caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">x=accumulate(b,e,i)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">x=accumulate(b,e,i,f)</td>
<td class="org-left">using f instead of +</td>
</tr>

<tr>
<td class="org-left">x=inner_product(b,e,b2,i)</td>
<td class="org-left">inner product of [b:e) and [b2:b2+(e−b)), i is initial value</td>
</tr>

<tr>
<td class="org-left">x=inner_product(b,e,b2,i,f,f2)</td>
<td class="org-left">using f and f2 instead of + and *</td>
</tr>

<tr>
<td class="org-left">p=partial_sum(b,e,out)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=partial_sum(b,e,out,f)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=adjacent_difference(b,e,out)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p=adjacent_difference(b,e,out,f)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">iota(b,e,v)</td>
<td class="org-left">For each element in [b:e) assign ++v: v+1, v+2, &#x2026;</td>
</tr>
</tbody>
</table>

<p>
A random number generator consists of two parts:
</p>
<ol class="org-ol">
<li>an <b>engine</b> that produces a sequence of random or pseudo-random values.</li>
<li>a <b>distribution</b> that maps those values into a mathematical distribution in a range.</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">auto</span> <span class="org-variable-name">die</span> = bind(<span class="org-type">uniform_int_distribution</span>&lt;&gt;{<span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">6</span>},
                  default_random_engine{});
  <span class="org-type">int</span> <span class="org-variable-name">x</span> = die();
</pre>
</div>

<p>
<code>valarray</code> in <code>&lt;valarray&gt;</code>  is less general and
more amenable to <b>optimization for numerical computation</b>.
</p>

<p>
Properties of numeric types are accessible through numeric_limits.
Use numeric_limits to check that the numeric types are adequate for their use.
</p>
</div>
</div>

<div id="outline-container-orga8233f9" class="outline-2">
<h2 id="orga8233f9"><span class="section-number-2">13.</span> Concurrency</h2>
<div class="outline-text-2" id="text-13">
<p>
threads, mutexes, lock() operations, packaged_tasks, and futures.
</p>

<p>
<b>task</b> s a computation that can potentially be executed concurrently with other computations.
A <b>thread</b> is the system-level representation of a task in a program.
</p>

<p>
A task is a function or a function object and launched as argument
by constructing a <code>std::thread</code> (found in <code>&lt;thread&gt;</code>).
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span>();  <span class="org-comment-delimiter">// </span><span class="org-comment">function</span>
  <span class="org-keyword">struct</span> <span class="org-type">F</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">function object</span>
    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">()</span>();
  };
  <span class="org-type">void</span> <span class="org-function-name">user</span>() {
    <span class="org-type">thread</span> <span class="org-variable-name">t1</span>{f};
    <span class="org-type">thread</span> <span class="org-variable-name">t2</span>{F()};
    t1.join(); <span class="org-comment-delimiter">// </span><span class="org-comment">wait for t1</span>
    t2.join(); <span class="org-comment-delimiter">// </span><span class="org-comment">wait for t2</span>
  }
</pre>
</div>

<p>
To <code>join</code> a thread means to wait for the thread to terminate.
</p>

<p>
Threads of a program <b>share a single address space</b>.
In this, threads differ from processes, which generally do not directly share data.
Since threads share an address space, they can communicate through shared objects.
</p>

<p>
The <code>ref()</code> is a type function from <code>&lt;functional&gt;</code> that unfortunately is needed
to tell the variadic template to treat some_vec as a reference,
rather than as an object.
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span>(<span class="org-type">vector</span>&lt;<span class="org-type">double</span>&gt; &amp;<span class="org-variable-name">v</span>);
  <span class="org-type">thread</span> <span class="org-variable-name">t1</span>{f, ref(some_vec)};
</pre>
</div>

<p>
pass the input data by const reference and to
pass the location of a place to deposit the result as a separate argument:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span>(<span class="org-keyword">const</span> <span class="org-type">vector</span>&lt;<span class="org-type">double</span>&gt; &amp;<span class="org-variable-name">v</span>, <span class="org-type">double</span> *<span class="org-variable-name">res</span>);
  <span class="org-type">thread</span> <span class="org-variable-name">t1</span>{f, cref(some_vec), &amp;res1};
</pre>
</div>
<p>
<code>cref</code> is for <code>const</code>.
</p>

<p>
A <code>mutex</code> in <code>&lt;mutex&gt;</code> is a mutual exclusion object.
A thread acquires a mutex using a <code>lock()</code> operation:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">mutex</span> <span class="org-variable-name">m</span>;
  <span class="org-type">int</span> <span class="org-variable-name">sh</span>;
  <span class="org-type">void</span> <span class="org-function-name">f</span>() {
    <span class="org-type">unique_lock</span>&lt;<span class="org-type">mutex</span>&gt; <span class="org-variable-name">lck</span>{m};
    sh += <span class="org-highlight-numbers-number">7</span>;
  } <span class="org-comment-delimiter">// </span><span class="org-comment">release mutex implicitly</span>
</pre>
</div>
<p>
The <code>unique_lock</code> releases the mutex with a call <code>m.unlock()</code>.
</p>

<p>
Acquiring several locks simultaneously to avoid deadlock:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">unique_lock</span>&lt;mutex&gt; <span class="org-variable-name">lck1</span> {m1,defer_lock};
  <span class="org-type">unique_lock</span>&lt;mutex&gt; <span class="org-variable-name">lck2</span> {m2,defer_lock};
  <span class="org-type">unique_lock</span>&lt;mutex&gt; <span class="org-variable-name">lck3</span> {m3,defer_lock};
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  lock(lck1,lck2,lck3);
</pre>
</div>

<p>
Sleep:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono</span>;
  <span class="org-constant">this_thread</span>::sleep_for(milliseconds{<span class="org-highlight-numbers-number">20</span>});
</pre>
</div>

<p>
The basic support for communicating using external events
is provided by condition_variables found in <code>&lt;condition_variable&gt;</code>.
A <code>condition_variable</code> is a mechanism allowing one thread to wait for another:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">queue</span>&lt;Message&gt; <span class="org-variable-name">mqueue</span>;
  <span class="org-type">condition_variable</span> <span class="org-variable-name">mcond</span>;
  <span class="org-type">mutex</span> <span class="org-variable-name">mmutex</span>;

  <span class="org-type">void</span> <span class="org-function-name">consumer</span>() {
    <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
      <span class="org-type">unique_lock</span>&lt;<span class="org-type">mutex</span>&gt; <span class="org-variable-name">lck</span>{mmutex};
      <span class="org-keyword">while</span> (mcond.wait(lck))
        <span class="org-comment-delimiter">/* </span><span class="org-comment">do nothing</span><span class="org-comment-delimiter"> */</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">m</span> = mqueue.front();
      mqueue.pop();
      lck.unlock();
      <span class="org-comment-delimiter">// </span><span class="org-comment">process m...</span>
    }
  }
  <span class="org-type">void</span> <span class="org-function-name">producer</span>() {
    <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
      <span class="org-type">Message</span> <span class="org-variable-name">m</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">... fill the message ...</span>
      <span class="org-type">unique_lock</span>&lt;<span class="org-type">mutex</span>&gt; <span class="org-variable-name">lck</span>{mmutex};
      mqueue.push(m);
      mcond.notify_one();
    }
  }
</pre>
</div>

<p>
<code>&lt;future&gt;</code>:
</p>
<ol class="org-ol">
<li>future and promise</li>
<li>packaged_task</li>
<li>async()</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">void</span> <span class="org-function-name">f</span>(<span class="org-type">promise</span>&lt;X&gt; &amp;<span class="org-variable-name">px</span>) {
    <span class="org-keyword">try</span> {
      <span class="org-type">X</span> <span class="org-variable-name">res</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
      px.set_value(res);
    } <span class="org-keyword">catch</span> (<span class="org-function-name">...</span>) {
      px.set_exception(current_exception()); <span class="org-comment-delimiter">// </span><span class="org-comment">pass the exception</span>
    }
  }
  <span class="org-type">void</span> <span class="org-function-name">g</span>(<span class="org-type">future</span>&lt;<span class="org-type">X</span>&gt; &amp;<span class="org-variable-name">fx</span>) { <span class="org-type">X</span> <span class="org-variable-name">v</span> = fx.get(); <span class="org-comment-delimiter">/* </span><span class="org-comment">block</span><span class="org-comment-delimiter"> */</span> }
</pre>
</div>

<p>
The packaged_task type is provided to simplify setting up tasks
connected with futures and promises to be run on threads:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-type">double</span> <span class="org-function-name">accum</span>(<span class="org-type">double</span>&#8727; beg, <span class="org-type">double</span>&#8727; end, <span class="org-type">double</span> <span class="org-variable-name">init</span>) {
    <span class="org-keyword">return</span> accumulate(beg, end, init);
  }
  <span class="org-type">double</span> <span class="org-function-name">sum</span>(<span class="org-type">vector</span>&lt;<span class="org-type">double</span>&gt;&amp; <span class="org-variable-name">v</span>) {
    <span class="org-keyword">using</span> <span class="org-type">Task_type</span> = <span class="org-type">double</span>(<span class="org-type">double</span>&#8727;, <span class="org-type">double</span>&#8727;, <span class="org-type">double</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">accumulate</span>
    <span class="org-type">packaged_task</span>&lt;Task_type&gt; <span class="org-variable-name">pt0</span>{accum};
    <span class="org-type">packaged_task</span>&lt;Task_type&gt; <span class="org-variable-name">pt1</span>{accum};
    <span class="org-type">future</span>&lt;<span class="org-type">double</span>&gt; <span class="org-variable-name">f0</span>{pt0.get_future()};
    <span class="org-type">future</span>&lt;<span class="org-type">double</span>&gt; <span class="org-variable-name">f1</span>{pt1.get_future()};

    <span class="org-type">double</span>&#8727; first = &amp;v[<span class="org-highlight-numbers-number">0</span>];
    <span class="org-type">thread</span> <span class="org-variable-name">t1</span>{move(pt0), first, first + v.size() / <span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">0</span>};
    <span class="org-type">thread</span> <span class="org-variable-name">t2</span>{move(pt1), first + v.size() / <span class="org-highlight-numbers-number">2</span>, first + v.size(), <span class="org-highlight-numbers-number">0</span>};
    <span class="org-keyword">return</span> f0.get() + f1.get();
  }
</pre>
</div>

<p>
Using <code>async()</code>, you don’t have to think about threads and locks.
Instead, you think just in terms of tasks that potentially compute their results asynchronously:
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span class="org-keyword">auto</span> <span class="org-variable-name">v0</span> = &amp;v[<span class="org-highlight-numbers-number">0</span>]; <span class="org-keyword">auto</span> <span class="org-variable-name">sz</span> = v.size();
  <span class="org-keyword">auto</span> <span class="org-variable-name">f0</span> = async(accum, v0, v0 + sz / <span class="org-highlight-numbers-number">4</span>, <span class="org-highlight-numbers-number">0.0</span>);
  <span class="org-keyword">auto</span> <span class="org-variable-name">f1</span> = async(accum, v0 + sz / <span class="org-highlight-numbers-number">4</span>, v0 + sz / <span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">0.0</span>);
  <span class="org-keyword">auto</span> <span class="org-variable-name">f2</span> = async(accum, v0 + sz / <span class="org-highlight-numbers-number">2</span>, v0 + sz&#8727;3 / <span class="org-highlight-numbers-number">4</span>, <span class="org-highlight-numbers-number">0.0</span>);
  <span class="org-keyword">auto</span> <span class="org-variable-name">f3</span> = async(accum, v0 + sz&#8727;3 / <span class="org-highlight-numbers-number">4</span>, v0 + sz, <span class="org-highlight-numbers-number">0.0</span>);
  <span class="org-comment-delimiter">// </span><span class="org-comment">f0.get() + f1.get() + f2.get() + f3.get();</span>
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
